#basic operation on matrices
import numpy as np

# Define the matrices
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])
C = np.array([[-1, 2], [3, 0]])
D = np.array([[-1, 2, 3], [4, 0, 6]])
E = np.array([[1, 2], [4, 5], [7, 8]])

# Problem 1: Matrix Addition and Subtraction
A_plus_B = A + B
B_minus_A = B - A
A_plus_C = A + C
# D + E cannot be added due to shape mismatch

# Problem 2: Scalar Multiplication
half_A = 0.5 * A
two_B = 2 * B
neg_three_C = -3 * C
four_D = 4 * D

# Problem 3: Matrix Multiplication
A_dot_B = np.dot(A, B)
B_dot_A = np.dot(B, A)
# A * D is not possible due to incompatible shapes
D_dot_E = np.dot(D, E)

# Display results
print("Problem 1:")
print("A + B =\n", A_plus_B)
print("B - A =\n", B_minus_A)
print("A + C =\n", A_plus_C)

print("\nProblem 2:")
print("1/2 A =\n", half_A)
print("2B =\n", two_B)
print("-3C =\n", neg_three_C)
print("4D =\n", four_D)

print("\nProblem 3:")
print("A * B =\n", A_dot_B)
print("B * A =\n", B_dot_A)
print("D * E =\n", D_dot_E)


#determinants

# Define the matrices
A = np.array([[2, 3], [1, 4]])
B = np.array([[5, 6], [7, 8]])
C = np.array([[-1, 2], [3, 0]])

D = np.array([[1, 0, 2], [-1, 3, 1], [2, 4, -2]])
E = np.array([[3, 1, -1], [0, 2, 4], [5, 3, 2]])
F = np.array([[2, -3, 1], [1, 4, -2], [1, 5, 3]])

# Calculate determinants
det_A = np.linalg.det(A)
det_B = np.linalg.det(B)
det_C = np.linalg.det(C)

det_D = np.linalg.det(D)
det_E = np.linalg.det(E)
det_F = np.linalg.det(F)

# Print the results
print("Determinant of A:", det_A)
print("Determinant of B:", det_B)
print("Determinant of C:", det_C)
print("Determinant of D:", det_D)
print("Determinant of E:", det_E)
print("Determinant of F:", det_F)


#determinants using laplaces expansion
import numpy as np

# Define the matrices
A = np.array([[2, 3, 1], [1, 4, 0], [3, 2, 1]])
B = np.array([[2, 3, 1], [1, 4, 0], [3, 2, 0]])
C = np.array([[2, 3, 1, 4], [1, 4, 0, 0], [3, 2, 1, 5], [2, 1, 4, 0]])
D = np.array([[2, 3, 1, 4, 5], [1, 4, 0, 0, 7], [3, 0, 0, 0, 0], [2, 1, 4, 3, 2], [1, 2, 3, 4, 5]])

# Function to calculate determinant using Laplace's expansion
def laplace_expansion(matrix):
    if matrix.shape == (1, 1):
        return matrix[0, 0]
    else:
        det = 0
        for j in range(matrix.shape[1]):
            submatrix = np.delete(np.delete(matrix, 0, 0), j, 1)
            det += ((-1) ** j) * matrix[0, j] * laplace_expansion(submatrix)
        return det

# Calculate determinants using Laplace's expansion
det_A = laplace_expansion(A)
det_B = laplace_expansion(B)
det_C = laplace_expansion(C)
det_D = laplace_expansion(D)

# Print the results
print("Determinant of A:", det_A)
print("Determinant of B:", det_B)
print("Determinant of C:", det_C)
print("Determinant of D:", det_D)

#gauss method
import numpy as np

def determinant_from_upper_triangular(matrix):
    """
    Calculates the determinant of a matrix by reducing it to upper triangular form.

    Args:
        matrix: The input matrix as a NumPy array.

    Returns:
        The determinant of the matrix.
    """

    if not isinstance(matrix, np.ndarray):
        raise TypeError("Input must be a NumPy array.")

    # Make a copy of the matrix to avoid modifying the original
    matrix = matrix.copy()

    # Row operations to get upper triangular form
    for i in range(matrix.shape[0] - 1):
        for j in range(i + 1, matrix.shape[0]):
            factor = matrix[j, i] / matrix[i, i]
            matrix[j, :] -= factor * matrix[i, :]

    # Calculate the determinant as the product of diagonal elements
    determinant = np.prod(np.diag(matrix))

    return determinant


# Define the matrices
A = np.array([[1, 2], [-1, 8]])
B = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# Calculate determinants
det_A = determinant_from_upper_triangular(A)
det_B = determinant_from_upper_triangular(B)

# Print the results
print("Determinant of A:", det_A)
print("Determinant of B:", det_B)


#Ä±nverse of matrix

import numpy as np

# Define matrix A
A = np.array([[2, 0, 1], [0, 1, 0], [1, 2, 0]])

# Find the inverse of A
A_inv = np.linalg.inv(A)

# Verify the result by multiplying A with its inverse
I = np.dot(A, A_inv)

# Print the inverse of A
print("Inverse of A:\n", A_inv)

# Print the verification result
print("A * A_inv:\n", I)

# Define matrix B
B = np.array([[4, -3, 7], [-1, 6, 3], [2, 9, 1]])

# Determine the rank of B
rank_B = np.linalg.matrix_rank(B)

# Print the rank of B
print("Rank of B:", rank_B)

#inverse of matrix using the gauss method
import numpy as np

def gauss_jordan_inverse(matrix):
    """
    Finds the inverse of a matrix using the Gauss-Jordan elimination method.

    Args:
        matrix: The input matrix as a NumPy array.

    Returns:
        The inverse of the matrix if it exists, otherwise None.
    """

    if not isinstance(matrix, np.ndarray):
        raise TypeError("Input must be a NumPy array.")

    n = matrix.shape[0]
    augmented_matrix = np.hstack((matrix, np.eye(n)))

    for i in range(n):
        # Find pivot row
        pivot_row = i
        for j in range(i + 1, n):
            if abs(augmented_matrix[j, i]) > abs(augmented_matrix[pivot_row, i]):
                pivot_row = j
        augmented_matrix[[i, pivot_row]] = augmented_matrix[[pivot_row, i]]

        # Make pivot element 1
        augmented_matrix[i, :] /= augmented_matrix[i, i]

        # Eliminate other elements in the column
        for j in range(n):
            if j != i:
                augmented_matrix[j, :] -= augmented_matrix[i, :] * augmented_matrix[j, i]

    # Check if the matrix is invertible
    for i in range(n):
        if abs(augmented_matrix[i, i]) < 1e-10:
            return None  # Matrix is not invertible

    # Extract the inverse matrix
    inverse = augmented_matrix[:, n:]

    return inverse

# Define the matrices
A = np.array([[1, 2], [3, 4]])
B = np.array([[1, 2, 3], [4, 5, 1], [2, 3, 2]])
C = np.array([[0, 0, 1], [0, 1, 0], [1, 0, 0]])

# Find inverses
A_inv = gauss_jordan_inverse(A)
B_inv = gauss_jordan_inverse(B)
C_inv = gauss_jordan_inverse(C)

# Print the results
print("Inverse of A:\n", A_inv)
print("Inverse of B:\n", B_inv)
print("Inverse of C:\n", C_inv)


#linear equations old school
def solve_linear_equations(equations):
    """
    Solves a system of linear equations using elimination method.

    Args:
        equations: A list of strings representing the equations. Each string should have the format "ax+by+cz+...=d".

    Returns:
        A dictionary containing the solutions for each variable, or None if no solution or infinite solutions exist.
    """

    # Extract coefficients and constants from equations
    coefficients = []
    constants = []
    for equation in equations:
        lhs, rhs = equation.split("=")
        terms = lhs.split("+")
        row = []
        for term in terms:
            if term.startswith("-"):
                term = term[1:]
                row.append(-float(term.split("*")[0]))
            else:
                row.append(float(term.split("*")[0]))
        row.append(float(rhs))
        coefficients.append(row)

    # Perform Gaussian elimination
    num_equations = len(coefficients)
    for i in range(num_equations - 1):
        pivot_row = i
        for j in range(i + 1, num_equations):
            if abs(coefficients[j][i]) > abs(coefficients[pivot_row][i]):
                pivot_row = j
        coefficients[i], coefficients[pivot_row] = coefficients[pivot_row], coefficients[i]

        for j in range(i + 1, num_equations):
            factor = coefficients[j][i] / coefficients[i][i]
            for k in range(i, num_equations + 1):
                coefficients[j][k] -= factor * coefficients[i][k]

    # Check for no solution or infinite solutions
    for i in range(num_equations):
        if all(coefficients[i][j] == 0 for j in range(num_equations)) and coefficients[i][-1] != 0:
            return None  # No solution

    # Back-substitution to find solutions
    solutions = {}
    for i in range(num_equations - 1, -1, -1):
        solution = coefficients[i][-1]
        for j in range(i + 1, num_equations):
            solution -= coefficients[i][j] * solutions[f"x{j + 1}"]
        solution /= coefficients[i][i]
        solutions[f"x{i + 1}"] = solution

    return solutions

# Example usage
equations1 = ["3x-2y=5", "2x+3y=7"]
equations2 = ["2x-3y=10", "4x+5y=20"]
equations3 = ["2x-y+z=3", "x+2y-z=1", "3x-y+2z=11"]
equations4 = ["2x-3y+4z+2t=2", "3x+2y-5z+3t=3", "4x-3y+2z-5t=4", "5x+4y-3z+2t=5"]

solutions1 = solve_linear_equations(equations1)
solutions2 = solve_linear_equations(equations2)
solutions3 = solve_linear_equations(equations3)
solutions4 = solve_linear_equations(equations4)

print("Solutions for equations1:", solutions1)
print("Solutions for equations2:", solutions2)
print("Solutions for equations3:", solutions3)
print("Solutions for equations4:", solutions4)

#Linear equations by Cramer's Rule

import numpy as np

def cramers_rule(coefficients, constants):
    """
    Solves a system of linear equations using Cramer's Rule.

    Args:
        coefficients: A list of lists representing the coefficients of the variables.
        constants: A list of constants on the right-hand side of the equations.

    Returns:
        A list of solutions for the variables, or None if Cramer's Rule cannot be applied.
    """

    if len(coefficients) != len(constants):
        return None  # Number of equations must match number of constants

    n = len(coefficients)
    det_D = np.linalg.det(coefficients)

    if det_D == 0:
        return None  # Cramer's Rule cannot be applied if det(D) = 0

    solutions = []
    for i in range(n):
        D_i = coefficients.copy()
        D_i[:, i] = constants
        det_D_i = np.linalg.det(D_i)
        solutions.append(det_D_i / det_D)

    return solutions

# Example usage
# Problem 1
coefficients1 = [[2, -3], [3, 5]]
constants1 = [7, 2]
solutions1 = cramers_rule(coefficients1, constants1)
print("Solutions for Problem 1:", solutions1)

# Problem 2
coefficients2 = [[2, 1, -1], [1, -1, 2], [3, 0, -2]]
constants2 = [1, 4, -1]
solutions2 = cramers_rule(coefficients2, constants2)
print("Solutions for Problem 2:", solutions2)

# Problem 3
coefficients3 = [[1, 1, 1, -1], [1, -1, 2, 0], [2, -3, 0, 1], [3, 1, 3, -4]]
constants3 = [2, 6, 4, -2]
solutions3 = cramers_rule(coefficients3, constants3)
print("Solutions for Problem 3:", solutions3)

# Problem 4 (Cramer's Rule cannot be applied)
coefficients4 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
constants4 = [3, 2, 1]
solutions4 = cramers_rule(coefficients4, constants4)
print("Solutions for Problem 4:", solutions4)

# Linear equations by Gauss Elimination
import numpy as np

def gauss_elimination(coefficients, constants):
    """
    Solves a system of linear equations using Gaussian Elimination.

    Args:
        coefficients: A list of lists representing the coefficients of the variables.
        constants: A list of constants on the right-hand side of the equations.

    Returns:
        A list of solutions for the variables, or None if no solution or infinite solutions exist.
    """

    if len(coefficients) != len(constants):
        return None  # Number of equations must match number of constants

    n = len(coefficients)
    augmented_matrix = np.hstack((coefficients, np.array(constants).reshape(-1, 1)))

    for i in range(n):
        # Find pivot row
        pivot_row = i
        for j in range(i + 1, n):
            if abs(augmented_matrix[j, i]) > abs(augmented_matrix[pivot_row, i]):
                pivot_row = j
        augmented_matrix[[i, pivot_row]] = augmented_matrix[[pivot_row, i]]

        # Make pivot element 1
        if augmented_matrix[i, i] == 0:
            return None  # No solution or infinite solutions

        augmented_matrix[i, :] /= augmented_matrix[i, i]

        # Eliminate other elements in the column
        for j in range(n):
            if j != i:
                augmented_matrix[j, :] -= augmented_matrix[i, :] * augmented_matrix[j, i]

    # Check for no solution or infinite solutions
    for i in range(n):
        if all(augmented_matrix[i, j] == 0 for j in range(n)) and augmented_matrix[i, -1] != 0:
            return None  # No solution

    # Extract solutions
    solutions = augmented_matrix[:, -1]

    return solutions

# Example usage
# Problem 1
coefficients1 = [[1, -2, 2], [2, 1, 1], [3, 2, 1]]
constants1 = [4, 3, 0]
solutions1 = gauss_elimination(coefficients1, constants1)
print("Solutions for Problem 1:", solutions1)

# Problem 2
coefficients2 = [[1, 1, 1, -1], [2, 1, 1, 0], [1, -1, 1, 0], [3, 2, 1, 1]]
constants2 = [2, 3, 0, 1]
solutions2 = gauss_elimination(coefficients2, constants2)
print("Solutions for Problem 2:", solutions2)

# Problem 3
coefficients3 = [[1, 1, -1, -1], [2, 1, -2, 1], [3, 1, -3, 0], [2, -1, -2, 2]]
constants3 = [0, 4, 0, 3]
solutions3 = gauss_elimination(coefficients3, constants3)
print("Solutions for Problem 3:", solutions3)

#Linear equations by Matrix Inversion

import numpy as np

def solve_matrix_inversion(coefficients, constants):
    """
    Solves a system of linear equations using the matrix inversion method.

    Args:
        coefficients: A list of lists representing the coefficients of the variables.
        constants: A list of constants on the right-hand side of the equations.

    Returns:
        A list of solutions for the variables, or None if the matrix is singular.
    """

    if len(coefficients) != len(constants):
        return None  # Number of equations must match number of constants

    try:
        coefficients_matrix = np.array(coefficients)
        constants_vector = np.array(constants).reshape(-1, 1)
        inverse_matrix = np.linalg.inv(coefficients_matrix)
        solutions = np.dot(inverse_matrix, constants_vector)
        return solutions.flatten()
    except np.linalg.LinAlgError:
        return None  # Matrix is singular

# Example usage
# Problem 1
coefficients1 = [[1, 2, 3], [0, 2, 3], [0, 0, 3]]
constants1 = [5, 4, 3]
solutions1 = solve_matrix_inversion(coefficients1, constants1)
print("Solutions for Problem 1:", solutions1)

# Problem 2
coefficients2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
constants2 = [41, 93, 145]
solutions2 = solve_matrix_inversion(coefficients2, constants2)
print("Solutions for Problem 2:", solutions2)

#vectors
import numpy as np
import matplotlib.pyplot as plt

def vector_length(vector):
    """
    Calculates the length (magnitude) of a vector.

    Args:
        vector: A list or NumPy array representing the vector.

    Returns:
        The length of the vector.
    """
    return np.linalg.norm(vector)

def unit_vector(vector):
    """
    Calculates the unit vector of a given vector.

    Args:
        vector: A list or NumPy array representing the vector.

    Returns:
        The unit vector of the given vector.
    """
    length = vector_length(vector)
    if length == 0:
        return None  # Zero vector has no unit vector
    return vector / length

def change_basis(vector, basis):
    """
    Finds the Cartesian coordinates of a vector in a given basis.

    Args:
        vector: A list or NumPy array representing the vector in the original basis.
        basis: A list of lists or a NumPy array representing the basis vectors.

    Returns:
        A list of Cartesian coordinates of the vector in the new basis.
    """
    coefficients = np.linalg.solve(np.array(basis).T, vector)
    return coefficients

# Problem 1
a = np.array([3, 4])
length_a = vector_length(a)
scalar_multiple = 1 / length_a
print(f"Problem 1: Scalar multiple to make vector a unit vector: {scalar_multiple}")

# Problem 2
b = np.array([1, 1])
length_b = vector_length(b)
unit_b = unit_vector(b)
print(f"Problem 2: Length of vector b: {length_b}")
print(f"Problem 2: Unit vector of b: {unit_b}")

# Problem 3
plt.figure()
plt.quiver(0, 0, b[0], b[1], angles='xy', scale_units='xy', scale=1, color='r', label='Vector b')
plt.quiver(0, 0, unit_b[0], unit_b[1], angles='xy', scale_units='xy', scale=1, color='b', label='Unit vector of b')
plt.xlim(-2, 2)
plt.ylim(-2, 2)
plt.grid()
plt.legend()
plt.show()

# Problem 4
c = np.array([1, 2, 3])
length_c = vector_length(c)
unit_c = unit_vector(c)
print(f"Problem 4: Length of vector c: {length_c}")
print(f"Problem 4: Unit vector of c: {unit_c}")

# Problem 5
v = np.array([2, 3, 4])
basis = [[1, 0, 1], [0, 1, 0], [1, 0, -1]]
cartesian_coordinates = change_basis(v, basis)
print(f"Problem 5: Cartesian coordinates of vector v in the given basis: {cartesian_coordinates}")

#vectors 2
import numpy as np
import matplotlib.pyplot as plt

def vector_addition(v1, v2):
    """
    Performs vector addition.

    Args:
        v1: The first vector.
        v2: The second vector.

    Returns:
        The sum of the two vectors.
    """
    return v1 + v2

def vector_length(v):
    """
    Calculates the length (magnitude) of a vector.

    Args:
        v: The vector.

    Returns:
        The length of the vector.
    """
    return np.linalg.norm(v)

def vector_cross_product(v1, v2):
    """
    Calculates the cross product of two vectors.

    Args:
        v1: The first vector.
        v2: The second vector.

    Returns:
        The cross product of the two vectors.
    """
    return np.cross(v1, v2)

def vector_dot_product(v1, v2):
    """
    Calculates the dot product of two vectors.

    Args:
        v1: The first vector.
        v2: The second vector.

    Returns:
        The dot product of the two vectors.
    """
    return np.dot(v1, v2)

def angle_between_vectors(v1, v2):
    """
    Calculates the angle between two vectors in degrees.

    Args:
        v1: The first vector.
        v2: The second vector.

    Returns:
        The angle between the vectors in degrees.
    """
    dot_product = vector_dot_product(v1, v2)
    lengths_product = vector_length(v1) * vector_length(v2)
    cos_theta = dot_product / lengths_product
    return np.arccos(cos_theta) * 180 / np.pi

# Problem 1
v1 = np.array([2, 1])
v2 = np.array([-1, 1])
v_sum = vector_addition(v1, v2)

plt.figure()
plt.quiver(0, 0, v1[0], v1[1], angles='xy', scale_units='xy', scale=1, color='r', label='Vector v1')
plt.quiver(0, 0, v2[0], v2[1], angles='xy', scale_units='xy', scale=1, color='b', label='Vector v2')
plt.quiver(0, 0, v_sum[0], v_sum[1], angles='xy', scale_units='xy', scale=1, color='g', label='Vector v1 + v2')
plt.xlim(-2, 2

#vectors3
import numpy as np
import matplotlib.pyplot as plt

def vector_addition(v1, v2):
    """
    Performs vector addition.

    Args:
        v1: The first vector.
        v2: The second vector.

    Returns:
        The sum of the two vectors.
    """
    return v1 + v2

def vector_length(v):
    """
    Calculates the length (magnitude) of a vector.

    Args:
        v: The vector.

    Returns:
        The length of the vector.
    """
    return np.linalg.norm(v)

def vector_cross_product(v1, v2):
    """
    Calculates the cross product of two vectors.

    Args:
        v1: The first vector.
        v2: The second vector.

    Returns:
        The cross product of the two vectors.
    """
    return np.cross(v1, v2)

def vector_dot_product(v1, v2):
    """
    Calculates the dot product of two vectors.

    Args:
        v1: The first vector.
        v2: The second vector.

    Returns:
        The dot product of the two vectors.
    """
    return np.dot(v1, v2)

def angle_between_vectors(v1, v2):
    """
    Calculates the angle between two vectors in degrees.

    Args:
        v1: The first vector.
        v2: The second vector.

    Returns:
        The angle between the vectors in degrees.
    """
    dot_product = vector_dot_product(v1, v2)
    lengths_product = vector_length(v1) * vector_length(v2)
    cos_theta = dot_product / lengths_product
    return np.arccos(cos_theta) * 180 / np.pi

# Problem 1
v1 = np.array([2, 1])
v2 = np.array([-1, 1])
v_sum = vector_addition(v1, v2)

plt.figure()
plt.quiver(0, 0, v1[0], v1[1], angles='xy', scale_units='xy', scale=1, color='r', label='Vector v1')
plt.quiver(0, 0, v2[0], v2[1], angles='xy', scale_units='xy', scale=1, color='b', label='Vector v2')
plt.quiver(0, 0, v_sum[0], v_sum[1], angles='xy', scale_units='xy', scale=1, color='g', label='Vector v1 + v2')
plt.xlim(-2, 2

#Equations of lines on a plane


import numpy as np
import matplotlib.pyplot as plt

def line_equation_from_points(p1, p2):
    """
    Finds the equation of the line passing through two points.

    Args:
        p1: Coordinates of the first point (x1, y1).
        p2: Coordinates of the second point (x2, y2).

    Returns:
        A tuple (a, b, c) representing the equation of the line in the form ax + by + c = 0.
    """
    x1, y1 = p1
    x2, y2 = p2
    a = y2 - y1
    b = -(x2 - x1)
    c = x1 * y2 - x2 * y1
    return a, b, c

def line_equation_parallel(point, line_equation):
    """
    Finds the equation of a line parallel to a given line and passing through a point.

    Args:
        point: Coordinates of the point (x, y).
        line_equation: Tuple (a, b, c) representing the equation of the line.

    Returns:
        A tuple (a, b, c) representing the equation of the parallel line.
    """
    a, b, c = line_equation
    return a, b, -(a * point[0] + b * point[1])

def line_equation_perpendicular(point, line_equation):
    """
    Finds the equation of a line perpendicular to a given line and passing through a point.

    Args:
        point: Coordinates of the point (x, y).
        line_equation: Tuple (a, b, c) representing the equation of the line.

    Returns:
        A tuple (a, b, c) representing the equation of the perpendicular line.
    """
    a, b, c = line_equation
    return b, -a, -(b * point[0] - a * point[1])

def line_intersection(line1, line2):
    """
    Finds the intersection point of two lines.

    Args:
        line1: Tuple (a1, b1, c1) representing the equation of the first line.
        line2: Tuple (a2, b2, c2) representing the equation of the second line.

    Returns:
        Coordinates of the intersection point as a tuple (x, y), or None if the lines are parallel.
    """
    a1, b1, c1 = line1
    a2, b2, c2 = line2

    if a1 * b2 == a2 * b1:
        return None  # Lines are parallel

    x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1)
    y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1)

    return x, y

def angle_between_lines(line1, line2):
    """
    Calculates the angle between two lines.

    Args:
        line1: Tuple (a1, b1, c1) representing the equation of the first line.
        line2: Tuple (a2, b2, c2) representing the equation of the second line.

    Returns:
        The angle between the lines in radians.
    """
    m1 = -a1 / b1
    m2 = -a2 / b2
    return np.arctan2(m2 - m1, 1 + m1 * m2)

def distance_point_to_line(point, line_equation):
    """
    Calculates the distance from a point to a line.

    Args:
        point: Coordinates of the point (x, y).
        line_equation: Tuple (a, b, c) representing the equation of the line.

    Returns:
        The distance from the point to the line.
    """
    a, b, c = line_equation
    x, y = point
    return abs(a * x + b * y + c) / np.sqrt(a**2 + b**2)

# Problem 1
A = (1, 2)
B = (3, 4)
line1_equation = line_equation_from_points(A, B)
print(f"Problem 1: Equation of the line passing through A and B: {line1_equation}")

# Problem 2
line2_equation = (1, -2, 1)  # y = 2x - 1
line_parallel_equation = line_equation_parallel(A, line2_equation)
print(f"Problem 2: Equation of the line parallel to y = 2x - 1 and passing through A: {line_parallel_equation}")

# Problem 3
line_perpendicular_equation = line_equation_perpendicular(A, line2_equation)
print(f"Problem 3: Equation of the line perpendicular to y = 2x - 1 and passing through A: {line_perpendicular_equation}")

# Problem 4
line3_equation = (3, -2, -2)  # 3x - 2y - 2 = 0
line4_equation = (2, -3, 2)  # 2x - 3y + 2 = 0
intersection_point = line_intersection(line3_equation, line4_equation)
angle = angle_between_lines(line3_equation, line4_equation)
print(f"Problem 4: Intersection point of the lines: {intersection_point}")
print(f"Problem 4: Angle between the lines: {angle:.2f} radians")

# Problem 5
v = np.array([2, 3])
line_parallel_to_vector_equation = (-v[1], v[0], v[1] * A[0] - v[0] * A[1])
print(f"Problem 5: Equation of the line passing through A and parallel to vector [2, 3]: {line_parallel_to_vector_equation}")

# Problem 6
line5_equation = (1, 1, 1)  # x + y + 1 = 0
line_perpendicular_equation = line_equation_perpendicular((0, 0), line5_equation)
line_parallel_equation = line_equation_parallel((0, 0), line5_equation)
print(f"Problem 6: Example of a line perpendicular to x + y + 1 = 0: {line_perpendicular_equation}")
print(f"Problem 6: Example of a line parallel to x + y + 1 = 0: {line_parallel_equation}")

# Problem 7
distance = distance_point_to_line(A, line2_equation)
print(f"Problem 7: Distance from point A to the line y = 2x + 3: {distance}")

# Problem 8
A = (2, 0)
B = (0, 3)
line_equation_from_points = line_equation_from_points(A, B)
print(f"Problem 8: Equation of the line passing through A(2, 0) and B(0, 3): {line_equation_from_points}")

# Problem 9
line6_equation = (1, -1, -3)  # y = x + 3
angle = np.arctan2(1, 1)  # Slope of the line is 1
print(f"Problem 9: Angle between the line y = x + 3 and the Ox axis: {angle:.2f} radians")

# Problem 10
line7_equation = (1, 1, 1)  # x + y + 1 = 0
perpendicular_vector = np.array([1, 1])
print(f"Problem 10: A vector perpendicular to the line x + y + 1 = 0: {perpendicular_vector}")

#Equations of second-order curves (conic sections)

import numpy as np

def circle_equation(center, radius):
    """
    Finds the equation of a circle given its center and radius.

    Args:
        center: A tuple representing the center coordinates (x, y).
        radius: The radius of the circle.

    Returns:
        A string representing the equation of the circle in the form (x-a)^2 + (y-b)^2 = r^2.
    """
    x0, y0 = center
    return f"(x - {x0})^2 + (y - {y0})^2 = {radius}^2"

center = (1, 2)
radius = 3
circle_eq = circle_equation(center, radius)
print("Equation of the circle:", circle_eq)

#Equations of planes in space


import numpy as np

def plane_equation_from_points(A, B, C):
    """
    Finds the equation of the plane passing through three points.

    Args:
        A: Coordinates of the first point (x1, y1, z1).
        B: Coordinates of the second point (x2, y2, z2).
        C: Coordinates of the third point (x3, y3, z3).

    Returns:
        A tuple (a, b, c, d) representing the equation of the plane in the form ax + by + cz + d = 0.
    """
    # Calculate the normal vector to the plane using cross product of vectors AB and AC
    AB = np.array(B) - np.array(A)
    AC = np.array(C) - np.array(A)
    normal_vector = np.cross(AB, AC)

    # Calculate the value of d
    a, b, c = normal_vector
    d = -np.dot(normal_vector, np.array(A))

    return a, b, c, d

def plane_equation_parallel(point, plane_equation):
    """
    Finds the equation of a plane parallel to a given plane and passing through a point.

    Args:
        point: Coordinates of the point (x, y, z).
        plane_equation: Tuple (a, b, c, d) representing the equation of the plane.

    Returns:
        A tuple (a, b, c, d) representing the equation of the parallel plane.
    """
    a, b, c, d = plane_equation
    return a, b, c, -(a * point[0] + b * point[1] + c * point[2])

def plane_equation_perpendicular(point, normal_vector):
    """
    Finds the equation of a plane perpendicular to a given vector and passing through a point.

    Args:
        point: Coordinates of the point (x, y, z).
        normal_vector: A NumPy array representing the normal vector.

    Returns:
        A tuple (a, b, c, d) representing the equation of the perpendicular plane.
    """
    a, b, c = normal_vector
    return a, b, c, -(a * point[0] + b * point[1] + c * point[2])

def line_of_intersection(plane1_equation, plane2_equation):
    """
    Finds the line of intersection of two planes.

    Args:
        plane1_equation: Tuple (a1, b1, c1, d1) representing the equation of the first plane.
        plane2_equation: Tuple (a2, b2, c2, d2) representing the equation of the second plane.

    Returns:
        A tuple representing the parametric equations of the line of intersection, or None if the planes are parallel.
    """
    # ... (Implementation of line intersection calculation using vector and parametric equations)
    # This part requires solving a system of equations and finding the parametric representation of the line.
    # The implementation would be more complex and is omitted for brevity.

def plane_equation_from_vectors(point, v1, v2):
    """
    Finds the equation of the plane passing through a point and parallel to two vectors.

    Args:
        point: Coordinates of the point (x, y, z).
        v1: The first vector.
        v2: The second vector.

    Returns:
        A tuple (a, b, c, d) representing the equation of the plane.
    """
    normal_vector = np.cross(v1, v2)
    return plane_equation_perpendicular(point, normal_vector)

def distance_point_to_plane(point, plane_equation):
    """
    Calculates the distance from a point to a

#17. Equations of second-order surfaces


import numpy as np

def sphere_equation(center, radius):
    """
    Finds the equation of a sphere given its center and radius.

    Args:
        center: A tuple representing the center coordinates (x, y, z).
        radius: The radius of the sphere.

    Returns:
        A string representing the equation of the sphere in the form (x-a)^2 + (y-b)^2 + (z-c)^2 = r^2.
    """
    x0, y0, z0 = center
    return f"(x - {x0})^2 + (y - {y0})^2 + (z - {z0})^2 = {radius}^2"

center = (1, 2, 3)
radius = 3
sphere_eq = sphere_equation(center, radius)
print("Equation of the sphere:", sphere_eq)

#Functions

import matplotlib.pyplot as plt
import numpy as np

# Define the functions
def f(x):
    return x**2

def g(x):
    return np.sqrt(x)

def h(x):
    return 1/x

def j(x):
    return np.sin(x)

# Create an array of x values
x = np.linspace(0, 5, 100)

# Calculate function values
y_f = f(x)
y_g = g(x)
y_h = h(x)
y_j = j(x)

# Plot the functions
plt.figure(figsize=(10, 6))
plt.plot(x, y_f, label='f(x) = x^2')
plt.plot(x, y_g, label='g(x) = âx')
plt.plot(x, y_h, label='h(x) = 1/x')
plt.plot(x, y_j, label='j(x) = sin(x)')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Functions')
plt.legend()
plt.grid(True)
plt.show()

# Find values at x = 2
print(f"f(2) = {f(2)}")
print(f"g(2) = {g(2)}")
print(f"h(2) = {h(2)}")
print(f"j(2) = {j(2)}")

#Limits of Sequences

import math

def calculate_limit_1(n):
    return (n**2 + 3*n) / (2*n**2 - 2*n)

# Calculate the limit numerically (approximation)
n_values = np.arange(100, 1000, 100)
limit_values = [calculate_limit_1(n) for n in n_values]

print("Approximate limit:", limit_values[-1])  # Print the last value as an approximation

# Analytical solution
# Divide both numerator and denominator by n^2
# lim_{nââ} (1 + 3/n) / (2 - 2/n) = 1/2
print("Analytical limit:", 1/2)

#Limits of Real Functions

import numpy as np

def calculate_limit_1(x):
    return (x**3 + 2*x**2) / (x**4 - 3*x**3)

# Calculate the limit numerically (approximation)
x_values = np.arange(100, 1000, 100)
limit_values = [calculate_limit_1(x) for x in x_values]

print("Approximate limit:", limit_values[-1])  # Print the last value as an approximation

# Analytical solution
# Divide both numerator and denominator by x^4
# lim_{xââ} (1/x + 2/x^2) / (1 - 3/x) = 0
print("Analytical limit:", 0)

erivatives
import math

def derivative(func, x):
    """Calculates the derivative of a function using the central difference method."""
    h = 1e-6  # Step size for numerical differentiation
    return (func(x + h) - func(x - h)) / (2 * h)

# Define the functions
def y1(x):
    return -3*x + 3

def y2(x):
    return math.pi*x + math.sin(1)

def y3(x):
    return 4 + math.sin(2)

def y4(x):
    return 2*x**3 - 3*x**2 + 8*x - 9

def y5(x):
    return 6*x**(1/3)

def y6(x):
    return math.sqrt(x)

def y7(x):
    return math.cos(x) + math.sin(x)

def y8(x):
    return 2*math.log(x)*math.cos(x)

def y9(x):
    return x*math.sin(x)

def y10(x):
    return (x+1)*(x+1)

def y11(x):
    return x/(x+1)

def y12(x):
    return (x+1)*math.exp(x)

def y13(x):
    return math.log(x**2)

def y14(x):
    return math.exp(-2*x)

def y15(x):
    return 1/math.sin(x+1)

def y16(x):
    return math.sqrt(2*x+1)

# Evaluate the derivatives at a specific point (e.g., x = 2)
x_value = 2

print("Derivatives at x =", x_value)
print("y1:", derivative(y1, x_value))
print("y2:", derivative(y2, x_value))
print("y3:", derivative(y3, x_value))
print("y4:", derivative(y4, x_value))
print("y5:", derivative(y5, x_value))
print("y6:", derivative(y6, x_value))
print("y7:", derivative(y7, x_value))
print("y8:", derivative(y8, x_value))
print("y9:", derivative(y9, x_value))
print("y10:", derivative(y10, x_value))
print("y11:", derivative(y11, x_value))
print("y12:", derivative(y12, x_value))
print("y13:", derivative(y13, x_value))
print("y14:", derivative(y14, x_value))
print("y15:", derivative(y15, x_value))
print("y16:", derivative(y16, x_value))

import math

def derivative(func, x):
    """Calculates the derivative of a function using the central difference method."""
    h = 1e-6  # Step size for numerical differentiation
    return (func(x + h) - func(x - h)) / (2 * h)

def ln_sin(x):
    return math.log(math.sin(x))

def cot(x):
    return 1 / math.tan(x)

x_value = math.pi/4  # Example value for x

# Calculate the derivative of ln(sin(x))
derivative_ln_sin = derivative(ln_sin, x_value)

# Calculate cot(x)
cot_x = cot(x_value)

# Compare the results
print("Derivative of ln(sin(x)) at x =", x_value, ":", derivative_ln_sin)
print("cot(x) at x =", x_value, ":", cot_x)

if abs(derivative_ln_sin - cot_x) < 1e-5:  # Tolerance for comparison
    print("The derivative of ln(sin(x)) is equal to cot(x)")
else:
    print("The derivative of ln(sin(x)) is not equal to cot(x)")

    import math

def derivative(func, x):
    """Calculates the derivative of a function using the central difference method."""
    h = 1e-6  # Step size for numerical differentiation
    return (func(x + h) - func(x - h)) / (2 * h)

def cos_function(x):
    return math.cos(x)

x_value = math.pi/4  # Example value for x

# Calculate the derivative of cos(x)
derivative_cos = derivative(cos_function, x_value)

# Calculate -f(x)
negative_cos = -math.cos(x_value)

# Compare the results
print("Derivative of cos(x) at x =", x_value, ":", derivative_cos)
print("-f(x) at x =", x_value, ":", negative_cos)

if abs(derivative_cos - negative_cos) < 1e-5:  # Tolerance for comparison
    print("f'(x) is equal to -f(x)")
else:
    print("f'(x) is not equal to -f(x)")

    import math

def lhospital(func1, func2, x):
    """Applies l'Hospital's Rule to find the limit of func1/func2 as x approaches a."""
    h = 1e-6  # Step size for numerical differentiation
    derivative_func1 = (func1(x + h) - func1(x - h)) / (2 * h)
    derivative_func2 = (func2(x + h) - func2(x - h)) / (2 * h)
    return derivative_func1 / derivative_func2

# Define the functions
def func1_a(x):
    return math.sin(x)

def func2_a(x):
    return x

def func1_b(x):
    return math.log(x)

def func2_b(x):
    return x

def func1_c(x):
    return math.exp(x)

def func2_c(x):
    return x

# Apply l'Hospital's Rule
limit_a = lhospital(func1_a, func2_a, 0)
limit_b = lhospital(func1_b, func2_b, math.inf)  # Note: math.inf represents infinity
limit_c = lhospital(func1_c, func2_c, math.inf)

print("Limit of sin(x)/x as x approaches 0:", limit_a)
print("Limit of ln(x)/x as x approaches infinity:", limit_b)
print("Limit of exp(x)/x as x approaches infinity:", limit_c)

def position(t):
    return 3*t**2 - 6*t + 1

def derivative(func, t):
    """Calculates the derivative of a function using the central difference method."""
    h = 1e-6  # Step size for numerical differentiation
    return (func(t + h) - func(t - h)) / (2 * h)

t_value = 2

# Calculate velocity (derivative of position)
velocity = derivative(position, t_value)

# Calculate acceleration (derivative of velocity)
acceleration = derivative(lambda t: derivative(position, t), t_value)

print("Velocity at t =", t_value, ":", velocity)
print("Acceleration at t =", t_value, ":", acceleration)

#Extremum

import numpy as np

def profit_function(u):
    return -2*u**2 + 50*u - 300

# Find the vertex of the parabola (maximum point)
u_vertex = -b / (2*a)  # where a = -2, b = 50

# Calculate the number of units for maximum profit
max_units = int(u_vertex)  # Round to the nearest integer

print("Number of units that maximize profit:", max_units)

import numpy as np

def rectangle_area(l):
    # Calculate the area of the rectangle given one side length
    w = (10 - 2*l) / 2  # Calculate the width based on the perimeter
    return l * w

# Find the maximum area using optimization
l_values = np.linspace(0, 5, 100)  # Create an array of possible side lengths
areas = rectangle_area(l_values)
max_area = np.max(areas)
max_index = np.argmax(areas)
max_length = l_values[max_index]
max_width = (10 - 2*max_length) / 2

print("Dimensions of the rectangle for maximum area:")
print("Length:", max_length)
print("Width:", max_width)

import numpy as np

def function(x):
    return x**2 + 3*x - 5

# Find the derivative of the function
def derivative(func, x):
    h = 1e-6  # Step size for numerical differentiation
    return (func(x + h) - func(x - h)) / (2 * h)

# Find the critical points (where derivative is zero)
x_values = np.linspace(-5, 5, 100)  # Create an array of x values
derivatives = [derivative(function, x) for x in x_values]
critical_points = x_values[np.abs(derivatives) < 1e-5]  # Find points where derivative is approximately zero

# Determine if the critical points are maxima or minima
extrema = []
for point in critical_points:
    if derivative(function, point - 1e-5) < 0 and derivative(function, point + 1e-5) > 0:
        extrema.append(("Minimum", point, function(point)))
    elif derivative(function, point - 1e-5) > 0 and derivative(function, point + 1e-5) < 0:
        extrema.append(("Maximum", point, function(point)))

# Print the results
for extremum in extrema:
    print(f"Extremum: {extremum[0]} at x = {extremum[1]}, f(x) = {extremum[2]}")

    import numpy as np

def function(x):
    return (x**2 + 2*x + 1) / (x - 1)

# Find the derivative of the function
def derivative(func, x):
    h = 1e-6  # Step size for numerical differentiation
    return (func(x + h) - func(x - h)) / (2 * h)

# Find the critical points (where derivative is zero)
x_values = np.linspace(-5, 5, 100)  # Create an array of x values
derivatives = [derivative(function, x) for x in x_values]
critical_points = x_values[np.abs(derivatives) < 1e-5]  # Find points where derivative is approximately zero

# Determine if the critical points are maxima or minima
extrema = []
for point in critical_points:
    if derivative(function, point - 1e-5) < 0 and derivative(function, point + 1e-5) > 0:
        extrema.append(("Minimum", point, function(point)))
    elif derivative(function, point - 1e-5) > 0 and derivative(function, point + 1e-5) < 0:
        extrema.append(("Maximum", point, function(point)))

# Print the results
for extremum in extrema:
    print(f"Extremum: {extremum[0]} at x = {extremum[1]}, f(x) = {extremum[2]}")

#Taylor Series

import matplotlib.pyplot as plt
import numpy as np

# Define the function
def cos_x(x):
    return np.cos(x)

# Define the Taylor series approximation
def taylor_cos(x):
    return 1 - (x**2)/2 + (x**4)/24

# Generate x values for plotting
x_values = np.linspace(-np.pi, np.pi, 100)

# Calculate the function values and Taylor series approximations
y_cos = cos_x(x_values)
y_taylor = taylor_cos(x_values)

# Plot the results
plt.plot(x_values, y_cos, label='cos(x)')
plt.plot(x_values, y_taylor, label='Taylor Series')
plt.legend()
plt.xlabel('x')
plt.ylabel('y')
plt.title('Taylor Series of cos(x) around x=0')
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Define the function
def h_x(x):
    return 1 / (1 - x)

# Define the Taylor series approximation
def taylor_h(x):
    return 1 + x + x**2 + x**3

# Generate x values for plotting
x_values = np.linspace(-0.9, 0.9, 100)  # Avoid x = 1 where h(x) is undefined

# Calculate the function values and Taylor series approximations
y_h = h_x(x_values)
y_taylor = taylor_h(x_values)

# Plot the results
plt.plot(x_values, y_h, label='h(x)')
plt.plot(x_values, y_taylor, label='Taylor Series')
plt.legend()
plt.xlabel('x')
plt.ylabel('y')
plt.title('Taylor Series of h(x) around x=0')
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Define the function
def f_x(x):
    return np.exp(np.sin(x))

# Define the derivative of the function
def df_dx(x):
    return np.cos(x) * np.exp(np.sin(x))

# Calculate the values at xo = Ï
xo = np.pi
f_xo = f_x(xo)
df_dx_xo = df_dx(xo)

# Define the tangent line equation
def tangent_line(x):
    return df_dx_xo * (x - xo) + f_xo

# Generate x values for plotting
x_values = np.linspace(0, 2*np.pi, 100)

# Calculate the function values and tangent line values
y_f = f_x(x_values)
y_tangent = tangent_line(x_values)

# Plot the results
plt.plot(x_values, y_f, label='f(x)')
plt.plot(x_values, y_tangent, label='Tangent Line')
plt.legend()
plt.xlabel('x')
plt.ylabel('y')
plt.title('Tangent Line to f(x) at x=Ï')
plt.grid(True)
plt.show()

#Integrals

import sympy as sp

# Define the symbolic variable
x = sp.Symbol('x')

# Compute the integrals
integral1 = sp.integrate(x**2 + 2*x + 3, x)
integral2 = sp.integrate(2*sp.sin(x), x)
integral3 = sp.integrate(3/x, x)
integral4 = sp.integrate(1/x**2, x)
integral5 = sp.integrate((x-5)**2, x)
integral6 = sp.integrate(sp.sin(x)**2 + sp.cos(x)**2, x)
integral7 = sp.integrate(5*sp.sin(x) + 3*sp.exp(x), x)
integral8 = sp.integrate(sp.sqrt(x), x)
integral9 = sp.integrate(sp.sqrt(10*x), x)
integral10 = sp.integrate(sp.cos(5/2*x + 3), x)
integral11 = sp.integrate(sp.cos(sp.log(x))/x, x)
integral12 = sp.integrate(x*sp.log(x), x)
integral13 = sp.integrate(x*sp.exp(x), x)

# Print the results
print("Integral 1:", integral1)
print("Integral 2:", integral2)
print("Integral 3:", integral3)
print("Integral 4:", integral4)
print("Integral 5:", integral5)
print("Integral 6:", integral6)
print("Integral 7:", integral7)
print("Integral 8:", integral8)
print("Integral 9:", integral9)
print("Integral 10:", integral10)
print("Integral 11:", integral11)
print("Integral 12:", integral12)
print("Integral 13:", integral13)

import sympy as sp
import matplotlib.pyplot as plt
import numpy as np

# Define the symbolic variable
x = sp.Symbol('x')

# Define the functions
f_x = 2*x + 1
g_x = x**2

# Calculate the definite integrals
integral_f = sp.integrate(f_x, (x, 0, sp.pi))
integral_g = sp.integrate(g_x, (x, 0, sp.pi))

# Print the results
print("Integral of f(x) over [0, Ï]:", integral_f)
print("Integral of g(x) over [0, Ï]:", integral_g)

# Generate x values for plotting
x_values = np.linspace(0, np.pi, 100)

# Calculate the function values
y_f = [f_x.subs(x, x_val) for x_val in x_values]
y_g = [g_x.subs(x, x_val) for x_val in x_values]

# Plot the results
plt.plot(x_values, y_f, label='f(x)')
plt.plot(x_values, y_g, label='g(x)')
plt.fill_between(x_values, y_f, alpha=0.2)
plt.fill_between(x_values, y_g, alpha=0.2)
plt.legend()
plt.xlabel('x')
plt.ylabel('y')
plt.title('Integrals over [0, Ï]')
plt.grid(True)
plt.show()

import sympy as sp
import matplotlib.pyplot as plt
import numpy as np

# Define the symbolic variable
x = sp.Symbol('x')

# Define the function
y = x**2 + 1

# Calculate the definite integral
area = sp.integrate(y, (x, 1, 2))

# Print the result
print("Area of the region:", area)

# Generate x values for plotting
x_values = np.linspace(1, 2, 100)

# Calculate the function values
y_values = [y.subs(x, x_val) for x_val in x_values]

# Plot the results
plt.plot(x_values, y_values)
plt.fill_between(x_values, y_values, alpha=0.2)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Area of the Region')
plt.grid(True)
plt.show()

import sympy as sp

# Define the symbolic variable
x = sp.Symbol('x')

# Calculate the derivative of sin(x)
df_dx = sp.diff(sp.sin(x), x)

# Calculate the length of the curve
length = sp.integrate(sp.sqrt(1 + df_dx**2), (x, 0, sp.pi))

# Print the result
print("Length of the sine curve:", length)

import sympy as sp

# Define the symbolic variable
t = sp.Symbol('t')

# Define the position function
x_t = 3*t**2 - 6*t + 1

# Calculate the velocity function (derivative of position)
v_t = sp.diff(x_t, t)

# Calculate the distance traveled
distance = sp.integrate(abs(v_t), (t, 0, 2))

# Print the result
print("Distance traveled by the particle:", distance)

#Differential Equations

import numpy as np
import matplotlib.pyplot as plt

# Define the solutions as functions
def y1(x):
    return np.exp(-x) + 1

def y2(x):
    return 2 * np.cosh(x)

def y3(x, omega, C1, C2):
    return C1 * np.cos(omega * x) + C2 * np.sin(omega * x)

# Define the wave function
def u(t, x, A, a, k):
    return A * np.cos(a * t + k * x)

# Set parameters for visualization
omega = 1
C1 = 1
C2 = 1
A = 1
a = 2 * np.pi
k = 2 * np.pi
T = 1
lambda_ = 1
c = lambda_ / T

# Generate x values for plotting
x_values = np.linspace(-5, 5, 100)

# Plot the solutions
plt.figure(figsize=(12, 4))

plt.subplot(1, 3, 1)
plt.plot(x_values, y1(x_values))
plt.title("y1(x) = 1 + e^(-x)")

plt.subplot(1, 3, 2)
plt.plot(x_values, y2(x_values))
plt.title("y2(x) = 2cosh(x)")

plt.subplot(1, 3, 3)
plt.plot(x_values, y3(x_values, omega, C1, C2))
plt.title("y3(x) = C1cos(Ïx) + C2sin(Ïx)")

plt.tight_layout()
plt.show()

# Generate t and x values for plotting the wave function
t_values = np.linspace(0, 2 * T, 100)
x_values = np.linspace(-2 * lambda_, 2 * lambda_, 100)
T, X = np.meshgrid(t_values, x_values)

# Calculate the wave function values
U = u(T, X, A, a, k)

# Plot the wave function
plt.figure()
plt.imshow(U, extent=[0, 2 * T, -2 * lambda_, 2 * lambda_], cmap='viridis', aspect='auto')
plt.xlabel('Time (t)')
plt.ylabel('Position (x)')
plt.title('Wave Function u(t, x)')
plt.colorbar()
plt.show()
