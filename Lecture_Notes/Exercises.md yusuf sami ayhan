# Mathematics

Exercises 2024/2025

## 1. Basic Operations on Matrices

For follwing matrices 

$$
\mathbf{A}=
\begin{pmatrix}
1 & 2 \\
3 & 4 
\end{pmatrix}
\qquad
\mathbf{B}=
\begin{pmatrix}
5 & 6 \\
7 & 8
\end{pmatrix}
\quad
\mathbf{C}=
\begin{pmatrix}
-1 & 2 \\
3 & 0
\end{pmatrix}
\qquad
\mathbf{D}=
\begin{pmatrix}
-1 & 2 & 3 \\
4 & 0 & 6 
\end{pmatrix}
\qquad
\mathbf{E}=
\begin{pmatrix}
1 & 2\\
4 & 5\\
7 & 8
\end{pmatrix}
$$

1. Calculate: $\mathbf{A}+\mathbf{B}$;  $\mathbf{B}-\mathbf{A}$;  $\mathbf{A}+\mathbf{C}$; $\mathbf{D}+\mathbf{E}$. 

2. Calculate $\frac{1}{2}\mathbf{A}$, $2\mathbf{B}$, $-3\mathbf{C}$, and $4\mathbf{D}$.

3. Calculate the products $\mathbf{A}\cdot \mathbf{B}$; $\mathbf{B} \cdot \mathbf{A}$; $\mathbf{A} \cdot \mathbf{D}$; $\mathbf{D} \cdot \mathbf{E}$.

## 2. Determinants 2x2 and 3x3

Calculate the determinants for the 2x2 and 3x3 matrices given below.

2x2 Matrices:

$$
\mathbf{A} =
\begin{pmatrix}
2 & 3 \\
1 & 4
\end{pmatrix}
, \qquad
\mathbf{B} =
\begin{pmatrix}
5 & 6 \\
7 & 8
\end{pmatrix}
, \qquad
\mathbf{C} =
\begin{pmatrix}
-1 & 2 \\
3 & 0
\end{pmatrix}
$$

3x3 Matrices:

$$
\mathbf{D} =
\begin{pmatrix}
1 & 0 & 2 \\
-1 & 3 & 1 \\
2 & 4 & -2
\end{pmatrix}
, \qquad
\mathbf{E} =
\begin{pmatrix}
3 & 1 & -1 \\
0 & 2 & 4 \\
5 & 3 & 2
\end{pmatrix}
, \qquad
\mathbf{F} =
\begin{pmatrix}
2 & -3 & 1 \\
1 & 4 & -2 \\
1 & 5 & 3
\end{pmatrix}
$$

## 3. Determinants using Laplace's Expansion

Calculate the determinants of the following matrices:

$$
\mathbf{A} =
\begin{pmatrix}
2 & 3 & 1 \\
1 & 4 & 0 \\
3 & 2 & 1
\end{pmatrix}
,\qquad
\mathbf{B} =
\begin{pmatrix}
2 & 3 & 1 \\
1 & 4 & 0 \\
3 & 2 & 0  \\
\end{pmatrix}
,\qquad
\mathbf{C} =
\begin{pmatrix}
2 & 3 & 1 & 4 \\
1 & 0 & 0 & 6 \\
3 & 2 & 1 & 5 \\
2 & 1 & 4 & 0
\end{pmatrix}
,\qquad
\mathbf{D} =
\begin{pmatrix}
2 & 3 & 1 & 4 & 5 \\
1 & 4 & 0 & 0 & 7 \\
3 & 0 & 0 & 0 & 0 \\
2 & 1 & 4 & 3 & 2 \\
1 & 2 & 3 & 4 & 5
\end{pmatrix}
$$

## 4. Determinants from the Gauss Method and Triangular Matrices

Perform row and column operations to reduce the following matrices to an upper triangular form and calculate their determinants by taking the product of the diagonal elements.

$$
\mathbf{A} = \begin{pmatrix}
12 & 3 \\
-18 & -4
\end{pmatrix}\qquad\qquad
\mathbf{B} = \begin{pmatrix} 
1 & 2 & 3 \\
4 & 5 & 6 \\
7 & 8 & 9 
\end{pmatrix}
$$

## 5. Inverse of a Matrix from the formula

1. Find the inverse matrix for matrix 

$$\mathbf{A}=\begin{pmatrix}
2 & 0 & 1 \\
0 & 1 & 0 \\
1 & 2 & 0
\end{pmatrix}$$

and verify if the result is correct.

2. Determine the rank of the matrix:

$$\mathbf{B} =
\begin{pmatrix}
4 & -3 & 7 \\
-1 & 6 & 3 \\
2 & 9 & 1
\end{pmatrix}$$

## 6. Inverse of a Matrix using the Gauss Method

Find the inverse matrices using the Gauss method:

$$
\mathbf{A} =
\begin{pmatrix}
1 & 2\\
3 & 4
\end{pmatrix}
, \qquad
\mathbf{B} =
\begin{pmatrix}
1 & 2 & 3 \\
4 & 5 & 1 \\
2 & 3 & 2
\end{pmatrix}
,\qquad
\mathbf{C} =
\begin{pmatrix}
0 & 0 & 1\\
0 & 1 & 0\\
1 & 0 & 0
\end{pmatrix}
$$

## 7. Linear Equations old school

Solve the following systems of equations without using matrices:

* $3x-2y=5, \quad 2x+3y=7$,
* $2x-3y=10, \quad 4x+5y=20$,
* $2x - y + z = 3, \quad x + 2y - z = 1, \quad 3x - y + 2z = 11$.
* $2x-3y+4z+2t=2, \quad 3x+2y-5z+3t=3, \quad 4x-3y+2z-5t=4, \quad 5x+4y-3z+2t=5$.

## 8. Linear equations by Cramer's Rule

1. Solve the system of equations:

$$\begin{cases}
   2x_1 - 3x_2 = 7\\
   3x_1 + 5x_2 = 2
\end{cases}$$

2. Solve the system of equations:

$$\begin{cases}
   2x + y - z = 1 \\
   x - y + 2z = 4 \\
   3x - 2z = -1
\end{cases}$$

3. Solve the system of equations:

$$\begin{cases}
   x + y + z - t = 2 \\
   x - z + 2t = 6 \\
   2x - 3y + t = 4 \\
   3x + y + 3z - 4t = -2
\end{cases}$$

4. Why can't the following system of equations be solved using Cramer's rule?

$$\begin{cases}
x_1 + 2x_2 + 3x_3 = 3 \\
4x_1 + 5x_2 + 6x_3 = 2 \\
7x_1 + 8x_2 + 9x_3 = 1
\end{cases}$$

## 9. Linear equations by Gauss Elimination

$$\begin{cases}
x + 2y - 2z = 4 \\
2x + y + z = 0 \\
3x + 2y + z = 1
\end{cases}
\quad
\begin{cases}
x + y + z - t = 2 \\
2x + y + z = 3 \\
-x + z - t = 0 \\
3x + 2y - z + 2t = -1
\end{cases}
\quad
\begin{cases}
x + y - z - t = 0 \\
2x + 3y - 2z + t = 4 \\
3x + 5z = 0 \\
-x + y - 3z + 2t = 3
\end{cases}
$$

## 10. Linear equations by Matrix Inversion

1. Solve the system of linear equations using the inverse matrix method:

$$
\begin{cases}
x + 2y + 3z = 5, \\
2y + 3z = 4, \\
3z = 3.
\end{cases}
$$

2. Solve the system of linear equations using the inverse matrix method:

$$
\begin{cases}
x_1 + 2x_2 + 3x_3 = 41, \\
4x_1 + 5x_2 + 6x_3 = 93, \\
7x_1 + 8x_2 + 9x_3 = 145.
\end{cases}
$$

## 11. Vectors I

1. By what number should vector $\mathbf{a} = [3, 4]$ be multiplied so that its length is equal to 1?

2. Calculate the length of vector $\mathbf{b} = [1, 1]$ and find the unit vector of this vector.

3. Plot the vector and the unit vector from the previous exercise.

4. Calculate the length of vector $\mathbf{c} = [1, 2, 3]$ and find the unit vector of this vector.

5. Find the Cartesian coordinates of vector $\mathbf{v} = [2, 3, 4]$ in the basis $\{\mathbf{b_1} = [1, 0, 1], \mathbf{b_2} = [0, 1, 0], \mathbf{b_3} = [1, 0, -1]\}$.

## 12. Vectors II

1. Perform the addition of vector $[2, 1]$ to vector $[-1, 1]$. Plot both vectors and their sum on a graph.

2. Calculate the area of the triangle spanned by vectors $[2, 1, 2]$ and $[-1, 1,1]$.

3. Calculate the volume of the parallelepiped spanned by vectors $[2, 1, -1]$, $[-1, 1, 0]$, and $[1, 2, 1]$.

4. Check if vectors $[2, 1]$ and $[-1, 1]$ are perpendicular.

5. Calculate the angle in degrees between vectors $[4,2,1]$ and $[1,3,2]$.

6. For three-dimensional vectors: $\mathbf{a}=[a_x, a_y, a_z]$, $\mathbf{b}=[b_x, b_y, b_z]$, $\mathbf{c}=[c_x, c_y, c_z]$, prove that the following identity is satisfied:

$$
\mathbf{a} \times (\mathbf{b} \times \mathbf{c}) = (\mathbf{a} \cdot \mathbf{c}) \mathbf{b} - (\mathbf{a} \cdot \mathbf{b}) \mathbf{c}.
$$

## 13. Vectors III

1. Divide the line segment connecting points $A(-1, 2)$ and $B(3, -2)$ in the ratio $1:3$. Illustrate the result on a graph.

2. Project vector $\mathbf{a} = (3, 4)$ onto the $OX$ and $OY$ axes. Illustrate the result on a graph.

3. Project vector $\mathbf{a} = (2,3)$ onto vector $\mathbf{b} = (1, 1)$. Ilustrate the result on a graph.

4. Project vector $\mathbf{b} = (1, 1)$ onto vector $\mathbf{a} = (2, 3)$. Ilustrate the result on a graph.

## 14. Equations of lines on a plane

* The line passes through points $A(1, 2)$ and $B(3, 4)$. Find the equation of the line.
* The line passes through point $A(1, 2)$ and is parallel to the line $y = 2x + 3$. Find the equation of the line.
* The line passes through point $A(1, 2)$ and is perpendicular to the line $y = 2x + 3$. Find the equation of the line.
* We have two lines $y = 2x + 3$ and $y = 3x + 2$. Find the intersection point of these lines and calculate the angle between them.
* Write the equation of the line passing through point $A(1, 2)$ and parallel to the vector $\mathbf{v} = [2, 3]$.
* We have the line $y = 2x + 3$. Find an example of a line perpendicular and parallel to it.
* We have the line $y = 2x + 3$ and point $A(1, 2)$. Find the distance from point $A$ to the line.
* The line intersects the coordinate axes at points $A(2, 0)$ and $B(0, 3)$. Find the equation of the line.
* Calculate the angle between the line $y = x + 3$ and the $Ox$ axis.
* Provide a vector perpendicular to the line $x + y + 1 = 0$.

## 15. Equations of second-order curves (conic sections)

* Find the equation of a circle with center at point $A(1,2)$ and radius $r=3$.
* Find the equation of a parabola intersecting the $Ox$ axis at points $x=2$, $x=4$, and passing through point $y(3)=1$.
* Find the center of the ellipse with the equation $x^2 + 4y^2 - 4x - 16y + 16 = 0$.
* Find the slope ($m>0$) of the line $y=mx-5$ that is tangent to the circle with the equation $x^2 + y^2=1$.
* Find the intersection points of the hyperbola $x^2 - y^2 = 1$ with the ellipse's line $x^2 + 4y^2 = 6$.
* For the given hyperbola $x^2 - y^2 = 1$, find the distance between its branches.

## 16. Equations of planes in space

* The plane passes through points $A(1, 2, 3)$, $B(3, 4, 5)$, and $C(2, 1, 4)$. Find the equation of the plane.
* The plane passes through point $A(1, 2, 3)$ and is parallel to the plane $2x + 3y + 4z = 5$. Find the equation of the plane.
* The plane passes through point $A(1, 2, 3)$ and is perpendicular to the normal vector $\mathbf{n} = [2, 3, 4]$. Find the equation of the plane.
* We have two planes $2x + 3y + 4z = 5$ and $3x + 4y + 2z = 6$. Find the line of intersection of these planes.
* Write the equation of the plane passing through point $A(1, 2, 3)$ and parallel to vectors $\vec{v_1} = [1, 0, 1]$ and $\vec{v_2} = [0, 1, -1]$.
* We have the plane $2x + 3y + 4z = 5$. Find an example of a plane parallel and perpendicular to it.
* We have the plane $2x + 3y + 4z = 5$ and point $A(1, 2, 3)$. Find the distance from point $A$ to this plane.
* The plane intersects the coordinate axes at points $A(2, 0, 0)$, $B(0, 3, 0)$, and $C(0, 0, 4)$. Find the equation of the plane.
* Calculate the angle between the plane $x + y + z = 1$ and the plane $x = 0$ (i.e., the $yz$ plane).
* Find the vector perpendicular to the plane $x + y + z = 1$.

## 17. Equations of second-order surfaces

* Write the equation of a sphere with center at point $P=(1,2,3)$ and radius $r=3$.
* Do the spheres with equations $x^2 + y^2 + z^2 = 1$ and $x^2 + y^2 + z^2 = 2$ have any common points?
* What curve in space is formed by the intersection of the sphere $x^2 + y^2 + z^2 = 1$ with the sphere $(x-1)^2 + y^2 + z^2 = 1$? Find the equation of this curve.
* Write the equation of the tangent plane to the paraboloid $z=(x-1)^2+y^2+1$ at point $P(1,0,1)$.


## 18. Functions

1. Draw in a single Geogebra notebook the following functions:
   - $f(x) = x^2$
   - $g(x) = \sqrt{x}$
   - $h(x) = \frac{1}{x}$
   - $j(x) = \sin(x)$

Find value of all the above functions at $x = 2$.

2. Let $f(x) = 3x - 1$ and $g(x) = \sqrt{x}$. Find:
   - $f(g(x))$
   - $g(f(x))$
   - $f(f(x))$
   - $g(g(x))$

and visualize functions in a single Geogebra notebook.

3. Let $f(x) = e^x$ and $g(x) = \ln(x)$. Check: $f(g(x))$ and $g(f(x))$. What do you notice?

4. We have function $f=\{(1,7), (2,9), (3,11)\}$. Give inverse function $f^{-1}$.

5. We have function $f=\{(1,7), (2,7), (3,11)\}$. Give inverse function $f^{-1}$.

6. We have function $f(x)= x-1$. Give inverse function $f^{-1}$. Show both functions on the same Geogebra notebook.

## 19. Limits of Sequences

1. Calculate:
   - $\displaystyle \lim_{n \to \infty} \frac{n^2 + 3n}{2 n^2 - 2n}$

   - $\displaystyle \lim_{n \to \infty} \frac{(2n+3)^3}{n^3-1}$

2. Prove using the squeeze theorem:
   - $\displaystyle\lim_{n \to \infty} \frac{\sin(n)}{n}$

4. Find the limit of the sequence:
   - $a_n = (1+\frac{1}{n})^n$

## 20. Limits of Real Functions

1. Compute:
   - $\displaystyle\lim_{x \to \infty} \frac{x^3 + 2x^2}{x^4 - 3x^3}$

2. Find:
   
   - $\displaystyle \lim_{x \to 0} \frac{\sin(3x)}{2x+1}$.

4. Find the asymptotes of the function:
  
   - $f(x) = \frac{x^2 - 1}{x^2 + 1}$
   - $g(x) = \frac{\sin(x)}{x^2+1}$

## 21. Derivatives

1. Compute derivatives of functions:
   * $y(x) = -3x+3$
   * $y(x) = \pi x + \sin(1)$
   * $y(x) = 4+\sin(2)$
   * $y(x) = 2x^3 - 3x^2 + 8x - 9$
   * $y(x) = 6 x^{1/3}$
   * $y(x) = \sqrt{x}$
   * $y(x) = \cos(x) + \sin(x)$
   * $y(x) = 2\sin(x) \cos(x)$
   * $y(x) = x\sin(x)$
   * $y(x) = (x+1)(x+1)$
   * $y(x) = \frac{x}{x+1}$
   * $y(x) = (x+1)\exp(x)$
   * $y(x) = \sin(x^2)$
   * $y(x) = \exp(-2x)$
   * $y(x) = \frac{1}{\sin(x+1)}$
   * $y(x) = \sqrt{2x+1}$

2. Prove:
   - $\frac{d}{dx} (\ln(\sin(x))) = \cot(x)$

3. For $f(x) = \cos(x)$, verify that $f''(x) = -f(x)$.

4. Using de l'Hospital's Rule, find the improper limits:
   - $\displaystyle \lim_{x\to 0} \frac{\sin{x}}{x}$

   - $\displaystyle \lim_{x\to \infty} \frac{\ln x}{x}$

   - $\displaystyle \lim_{x\to \infty} \frac{\exp(x)}{x}$

5. In physics, the position of a particle is given by $x(t) = 3t^2 - 6t + 1$. Find the velocity $V(t)=x'(t)$ and acceleration $a(t)=V'(t)=x''(t)$ of the particle at time $t = 2$.

## 22. Extremum

6. The profit function is $P(u) = -2u^2 + 50u - 300$, where $u$ is the number of units sold. Find the number of units that maximize profit.

7. You have 10 meters of string, and you need to use it to enclose the largest possible rectangular. Find the dimensions of the rectangle.

8. Find extremum od $f(x) = x^2 + 3x - 5$.

9. Find extremum of $f(x) =\frac{x^2+2x+1}{x-1}$.

## 23. Taylor Series

1. Find the Taylor series and visualize obtained functions in Geogebra:
   - $f(x) = \cos(x)$ around $x = 0$ up to the 4th degree.
   - $h(x) = 1/(1-x)$ around $x = 0$ up to the 4rd degree.
   - $g(x) = \sin(x)$ around $x = \pi$ up to the 4rd degree.

2. Find a tangent line $y = f'(x_0) (x-x_0) + f(x_0)$ to the function $f(x) = e^{\sin(x)}$ at $x_0 = \pi$. Hints for Geogebra visualization: define f(x), include slider s, define y = f'(s) (x-s) + f(s), and include point P(s, f(s)).

## 24. Integrals

1. Compute:
   - $\int 1 dx$
   - $\int (x^2 +2) dx$
   - $\int 2\sin(x) dx$
   - $\int \frac{3}{x} dx$
   - $\int \frac{1}{x^2} dx$
   - $\int \left( \frac{1}{3}x^4 - 5 \right) \, dx$
   - $\int (\sin^2 x + \cos^2 x) \, dx$
   - $\int (5 \sin x + 3e^x) \, dx$
   - $\int \sqrt[3]{x} \, dx$
   - $\int \sqrt{10x} \, dx$
   - $\int \cos\left(\frac{5}{2}x + 3\right) \, dx$
   - $\int \frac{\cos(\ln(x))}{x} \, dx$
   - $\int x \ln(x) \, dx$
   - $\int x e^x \, dx$

2. Calculate integrals over the interval $[0, \pi]$ and visualize them in Geogebra:
   - $f(x)=2x+1$
   - $g(x)=x^2$

3. Calculate the area of the region bounded by the lines:
$x = 1$, $x = 2$, $y = 0$, and $y = x^2 + 1$. Show it in Geogebra.

4. Calculate the area under the sine curve over the interval $[0, \pi]$, using:

$$P = \int_a^b f(x) \, dx = \int_0^\pi \sin(x) \, dx$$

5. Calculate the length of the sine curve over the same interval using:

$$L = \int_a^b \sqrt{1 + (f'(x))^2} \, dx= \int_0^\pi \sqrt{1 + \cos^2(x)} \, dx
$$ 

6. Find the distance of the moving particle between time $t=0$ and $t=2$ for the following position function: $x(t) = 3t^2 - 6t + 1$.

## 25. Differential Equations

1. Solve the following first-order ordinary differential equations:
   - $y'(x)= y$
   - $y'(x) = \frac{1}{2y(x)}$
  
3. Solve the first-order ordinary differential equations using the method of separation of variables for $x$ and $y=y(x)$:

   - $\frac{dy}{dx} = \frac{x}{y}$
   - $\frac{dy}{dx} = \frac{y}{x}$
   - $\frac{dy}{dx} = xy$

4. Solve the second-order ordinary differential equations:

   * $y''(x) + y'(x) = 0$, with boundary conditions $y(0) = 2$ and $y'(0) = -1$

   * $y''(x) - y(x)= 0$, with boundary conditions $y(0) = 2$ and $y'(0) = 0$

   * $\frac{d^2\,y(x)}{dx^2} = -\omega^2 y(x)$.

5. Check if the function $\psi(t, x) = A \cos(\omega t + kx)$ is a solution of the second-order partial differential equation (the so-called "wave equation"), where $v = \frac{\omega}{k} = \frac{2\pi / T}{2\pi / \lambda}$:

$$
\frac{\partial^2 \psi(t, x)}{\partial t^2} - v^2 \frac{\partial^2 \psi(t, x)}{\partial x^2} = 0.
$$



Original file line number	Diff line number	Diff line change
@@ -0,0 +1,1107 @@
#basic operation on matrices
import numpy as np

# Define the matrices
A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])
C = np.array([[-1, 2], [3, 0]])
D = np.array([[-1, 2, 3], [4, 0, 6]])
E = np.array([[1, 2], [4, 5], [7, 8]])

# Problem 1: Matrix Addition and Subtraction
A_plus_B = A + B
B_minus_A = B - A
A_plus_C = A + C
# D + E cannot be added due to shape mismatch

# Problem 2: Scalar Multiplication
half_A = 0.5 * A
two_B = 2 * B
neg_three_C = -3 * C
four_D = 4 * D

# Problem 3: Matrix Multiplication
A_dot_B = np.dot(A, B)
B_dot_A = np.dot(B, A)
# A * D is not possible due to incompatible shapes
D_dot_E = np.dot(D, E)

# Display results
print("Problem 1:")
print("A + B =\n", A_plus_B)
print("B - A =\n", B_minus_A)
print("A + C =\n", A_plus_C)

print("\nProblem 2:")
print("1/2 A =\n", half_A)
print("2B =\n", two_B)
print("-3C =\n", neg_three_C)
print("4D =\n", four_D)

print("\nProblem 3:")
print("A * B =\n", A_dot_B)
print("B * A =\n", B_dot_A)
print("D * E =\n", D_dot_E)


#determinants

# Define the matrices
A = np.array([[2, 3], [1, 4]])
B = np.array([[5, 6], [7, 8]])
C = np.array([[-1, 2], [3, 0]])

D = np.array([[1, 0, 2], [-1, 3, 1], [2, 4, -2]])
E = np.array([[3, 1, -1], [0, 2, 4], [5, 3, 2]])
F = np.array([[2, -3, 1], [1, 4, -2], [1, 5, 3]])

# Calculate determinants
det_A = np.linalg.det(A)
det_B = np.linalg.det(B)
det_C = np.linalg.det(C)

det_D = np.linalg.det(D)
det_E = np.linalg.det(E)
det_F = np.linalg.det(F)

# Print the results
print("Determinant of A:", det_A)
print("Determinant of B:", det_B)
print("Determinant of C:", det_C)
print("Determinant of D:", det_D)
print("Determinant of E:", det_E)
print("Determinant of F:", det_F)


#determinants using laplaces expansion
import numpy as np

# Define the matrices
A = np.array([[2, 3, 1], [1, 4, 0], [3, 2, 1]])
B = np.array([[2, 3, 1], [1, 4, 0], [3, 2, 0]])
C = np.array([[2, 3, 1, 4], [1, 4, 0, 0], [3, 2, 1, 5], [2, 1, 4, 0]])
D = np.array([[2, 3, 1, 4, 5], [1, 4, 0, 0, 7], [3, 0, 0, 0, 0], [2, 1, 4, 3, 2], [1, 2, 3, 4, 5]])

# Function to calculate determinant using Laplace's expansion
def laplace_expansion(matrix):
    if matrix.shape == (1, 1):
        return matrix[0, 0]
    else:
        det = 0
        for j in range(matrix.shape[1]):
            submatrix = np.delete(np.delete(matrix, 0, 0), j, 1)
            det += ((-1) ** j) * matrix[0, j] * laplace_expansion(submatrix)
        return det

# Calculate determinants using Laplace's expansion
det_A = laplace_expansion(A)
det_B = laplace_expansion(B)
det_C = laplace_expansion(C)
det_D = laplace_expansion(D)

# Print the results
print("Determinant of A:", det_A)
print("Determinant of B:", det_B)
print("Determinant of C:", det_C)
print("Determinant of D:", det_D)

#gauss method
import numpy as np

def determinant_from_upper_triangular(matrix):
    """
    Calculates the determinant of a matrix by reducing it to upper triangular form.

    Args:
        matrix: The input matrix as a NumPy array.

    Returns:
        The determinant of the matrix.
    """

    if not isinstance(matrix, np.ndarray):
        raise TypeError("Input must be a NumPy array.")

    # Make a copy of the matrix to avoid modifying the original
    matrix = matrix.copy()

    # Row operations to get upper triangular form
    for i in range(matrix.shape[0] - 1):
        for j in range(i + 1, matrix.shape[0]):
            factor = matrix[j, i] / matrix[i, i]
            matrix[j, :] -= factor * matrix[i, :]

    # Calculate the determinant as the product of diagonal elements
    determinant = np.prod(np.diag(matrix))

    return determinant


# Define the matrices
A = np.array([[1, 2], [-1, 8]])
B = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# Calculate determinants
det_A = determinant_from_upper_triangular(A)
det_B = determinant_from_upper_triangular(B)

# Print the results
print("Determinant of A:", det_A)
print("Determinant of B:", det_B)


#ınverse of matrix

import numpy as np

# Define matrix A
A = np.array([[2, 0, 1], [0, 1, 0], [1, 2, 0]])

# Find the inverse of A
A_inv = np.linalg.inv(A)

# Verify the result by multiplying A with its inverse
I = np.dot(A, A_inv)

# Print the inverse of A
print("Inverse of A:\n", A_inv)

# Print the verification result
print("A * A_inv:\n", I)

# Define matrix B
B = np.array([[4, -3, 7], [-1, 6, 3], [2, 9, 1]])

# Determine the rank of B
rank_B = np.linalg.matrix_rank(B)

# Print the rank of B
print("Rank of B:", rank_B)

#inverse of matrix using the gauss method
import numpy as np

def gauss_jordan_inverse(matrix):
    """
    Finds the inverse of a matrix using the Gauss-Jordan elimination method.

    Args:
        matrix: The input matrix as a NumPy array.

    Returns:
        The inverse of the matrix if it exists, otherwise None.
    """

    if not isinstance(matrix, np.ndarray):
        raise TypeError("Input must be a NumPy array.")

    n = matrix.shape[0]
    augmented_matrix = np.hstack((matrix, np.eye(n)))

    for i in range(n):
        # Find pivot row
        pivot_row = i
        for j in range(i + 1, n):
            if abs(augmented_matrix[j, i]) > abs(augmented_matrix[pivot_row, i]):
                pivot_row = j
        augmented_matrix[[i, pivot_row]] = augmented_matrix[[pivot_row, i]]

        # Make pivot element 1
        augmented_matrix[i, :] /= augmented_matrix[i, i]

        # Eliminate other elements in the column
        for j in range(n):
            if j != i:
                augmented_matrix[j, :] -= augmented_matrix[i, :] * augmented_matrix[j, i]

    # Check if the matrix is invertible
    for i in range(n):
        if abs(augmented_matrix[i, i]) < 1e-10:
            return None  # Matrix is not invertible

    # Extract the inverse matrix
    inverse = augmented_matrix[:, n:]

    return inverse

# Define the matrices
A = np.array([[1, 2], [3, 4]])
B = np.array([[1, 2, 3], [4, 5, 1], [2, 3, 2]])
C = np.array([[0, 0, 1], [0, 1, 0], [1, 0, 0]])

# Find inverses
A_inv = gauss_jordan_inverse(A)
B_inv = gauss_jordan_inverse(B)
C_inv = gauss_jordan_inverse(C)

# Print the results
print("Inverse of A:\n", A_inv)
print("Inverse of B:\n", B_inv)
print("Inverse of C:\n", C_inv)


#linear equations old school
def solve_linear_equations(equations):
    """
    Solves a system of linear equations using elimination method.

    Args:
        equations: A list of strings representing the equations. Each string should have the format "ax+by+cz+...=d".

    Returns:
        A dictionary containing the solutions for each variable, or None if no solution or infinite solutions exist.
    """

    # Extract coefficients and constants from equations
    coefficients = []
    constants = []
    for equation in equations:
        lhs, rhs = equation.split("=")
        terms = lhs.split("+")
        row = []
        for term in terms:
            if term.startswith("-"):
                term = term[1:]
                row.append(-float(term.split("*")[0]))
            else:
                row.append(float(term.split("*")[0]))
        row.append(float(rhs))
        coefficients.append(row)

    # Perform Gaussian elimination
    num_equations = len(coefficients)
    for i in range(num_equations - 1):
        pivot_row = i
        for j in range(i + 1, num_equations):
            if abs(coefficients[j][i]) > abs(coefficients[pivot_row][i]):
                pivot_row = j
        coefficients[i], coefficients[pivot_row] = coefficients[pivot_row], coefficients[i]

        for j in range(i + 1, num_equations):
            factor = coefficients[j][i] / coefficients[i][i]
            for k in range(i, num_equations + 1):
                coefficients[j][k] -= factor * coefficients[i][k]

    # Check for no solution or infinite solutions
    for i in range(num_equations):
        if all(coefficients[i][j] == 0 for j in range(num_equations)) and coefficients[i][-1] != 0:
            return None  # No solution

    # Back-substitution to find solutions
    solutions = {}
    for i in range(num_equations - 1, -1, -1):
        solution = coefficients[i][-1]
        for j in range(i + 1, num_equations):
            solution -= coefficients[i][j] * solutions[f"x{j + 1}"]
        solution /= coefficients[i][i]
        solutions[f"x{i + 1}"] = solution

    return solutions

# Example usage
equations1 = ["3x-2y=5", "2x+3y=7"]
equations2 = ["2x-3y=10", "4x+5y=20"]
equations3 = ["2x-y+z=3", "x+2y-z=1", "3x-y+2z=11"]
equations4 = ["2x-3y+4z+2t=2", "3x+2y-5z+3t=3", "4x-3y+2z-5t=4", "5x+4y-3z+2t=5"]

solutions1 = solve_linear_equations(equations1)
solutions2 = solve_linear_equations(equations2)
solutions3 = solve_linear_equations(equations3)
solutions4 = solve_linear_equations(equations4)

print("Solutions for equations1:", solutions1)
print("Solutions for equations2:", solutions2)
print("Solutions for equations3:", solutions3)
print("Solutions for equations4:", solutions4)

#Linear equations by Cramer's Rule

import numpy as np

def cramers_rule(coefficients, constants):
    """
    Solves a system of linear equations using Cramer's Rule.

    Args:
        coefficients: A list of lists representing the coefficients of the variables.
        constants: A list of constants on the right-hand side of the equations.

    Returns:
        A list of solutions for the variables, or None if Cramer's Rule cannot be applied.
    """

    if len(coefficients) != len(constants):
        return None  # Number of equations must match number of constants

    n = len(coefficients)
    det_D = np.linalg.det(coefficients)

    if det_D == 0:
        return None  # Cramer's Rule cannot be applied if det(D) = 0

    solutions = []
    for i in range(n):
        D_i = coefficients.copy()
        D_i[:, i] = constants
        det_D_i = np.linalg.det(D_i)
        solutions.append(det_D_i / det_D)

    return solutions

# Example usage
# Problem 1
coefficients1 = [[2, -3], [3, 5]]
constants1 = [7, 2]
solutions1 = cramers_rule(coefficients1, constants1)
print("Solutions for Problem 1:", solutions1)

# Problem 2
coefficients2 = [[2, 1, -1], [1, -1, 2], [3, 0, -2]]
constants2 = [1, 4, -1]
solutions2 = cramers_rule(coefficients2, constants2)
print("Solutions for Problem 2:", solutions2)

# Problem 3
coefficients3 = [[1, 1, 1, -1], [1, -1, 2, 0], [2, -3, 0, 1], [3, 1, 3, -4]]
constants3 = [2, 6, 4, -2]
solutions3 = cramers_rule(coefficients3, constants3)
print("Solutions for Problem 3:", solutions3)

# Problem 4 (Cramer's Rule cannot be applied)
coefficients4 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
constants4 = [3, 2, 1]
solutions4 = cramers_rule(coefficients4, constants4)
print("Solutions for Problem 4:", solutions4)

# Linear equations by Gauss Elimination
import numpy as np

def gauss_elimination(coefficients, constants):
    """
    Solves a system of linear equations using Gaussian Elimination.

    Args:
        coefficients: A list of lists representing the coefficients of the variables.
        constants: A list of constants on the right-hand side of the equations.

    Returns:
        A list of solutions for the variables, or None if no solution or infinite solutions exist.
    """

    if len(coefficients) != len(constants):
        return None  # Number of equations must match number of constants

    n = len(coefficients)
    augmented_matrix = np.hstack((coefficients, np.array(constants).reshape(-1, 1)))

    for i in range(n):
        # Find pivot row
        pivot_row = i
        for j in range(i + 1, n):
            if abs(augmented_matrix[j, i]) > abs(augmented_matrix[pivot_row, i]):
                pivot_row = j
        augmented_matrix[[i, pivot_row]] = augmented_matrix[[pivot_row, i]]

        # Make pivot element 1
        if augmented_matrix[i, i] == 0:
            return None  # No solution or infinite solutions

        augmented_matrix[i, :] /= augmented_matrix[i, i]

        # Eliminate other elements in the column
        for j in range(n):
            if j != i:
                augmented_matrix[j, :] -= augmented_matrix[i, :] * augmented_matrix[j, i]

    # Check for no solution or infinite solutions
    for i in range(n):
        if all(augmented_matrix[i, j] == 0 for j in range(n)) and augmented_matrix[i, -1] != 0:
            return None  # No solution

    # Extract solutions
    solutions = augmented_matrix[:, -1]

    return solutions

# Example usage
# Problem 1
coefficients1 = [[1, -2, 2], [2, 1, 1], [3, 2, 1]]
constants1 = [4, 3, 0]
solutions1 = gauss_elimination(coefficients1, constants1)
print("Solutions for Problem 1:", solutions1)

# Problem 2
coefficients2 = [[1, 1, 1, -1], [2, 1, 1, 0], [1, -1, 1, 0], [3, 2, 1, 1]]
constants2 = [2, 3, 0, 1]
solutions2 = gauss_elimination(coefficients2, constants2)
print("Solutions for Problem 2:", solutions2)

# Problem 3
coefficients3 = [[1, 1, -1, -1], [2, 1, -2, 1], [3, 1, -3, 0], [2, -1, -2, 2]]
constants3 = [0, 4, 0, 3]
solutions3 = gauss_elimination(coefficients3, constants3)
print("Solutions for Problem 3:", solutions3)

#Linear equations by Matrix Inversion

import numpy as np

def solve_matrix_inversion(coefficients, constants):
    """
    Solves a system of linear equations using the matrix inversion method.

    Args:
        coefficients: A list of lists representing the coefficients of the variables.
        constants: A list of constants on the right-hand side of the equations.

    Returns:
        A list of solutions for the variables, or None if the matrix is singular.
    """

    if len(coefficients) != len(constants):
        return None  # Number of equations must match number of constants

    try:
        coefficients_matrix = np.array(coefficients)
        constants_vector = np.array(constants).reshape(-1, 1)
        inverse_matrix = np.linalg.inv(coefficients_matrix)
        solutions = np.dot(inverse_matrix, constants_vector)
        return solutions.flatten()
    except np.linalg.LinAlgError:
        return None  # Matrix is singular

# Example usage
# Problem 1
coefficients1 = [[1, 2, 3], [0, 2, 3], [0, 0, 3]]
constants1 = [5, 4, 3]
solutions1 = solve_matrix_inversion(coefficients1, constants1)
print("Solutions for Problem 1:", solutions1)

# Problem 2
coefficients2 = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
constants2 = [41, 93, 145]
solutions2 = solve_matrix_inversion(coefficients2, constants2)
print("Solutions for Problem 2:", solutions2)

#vectors
import numpy as np
import matplotlib.pyplot as plt

def vector_length(vector):
    """
    Calculates the length (magnitude) of a vector.

    Args:
        vector: A list or NumPy array representing the vector.

    Returns:
        The length of the vector.
    """
    return np.linalg.norm(vector)

def unit_vector(vector):
    """
    Calculates the unit vector of a given vector.

    Args:
        vector: A list or NumPy array representing the vector.

    Returns:
        The unit vector of the given vector.
    """
    length = vector_length(vector)
    if length == 0:
        return None  # Zero vector has no unit vector
    return vector / length

def change_basis(vector, basis):
    """
    Finds the Cartesian coordinates of a vector in a given basis.

    Args:
        vector: A list or NumPy array representing the vector in the original basis.
        basis: A list of lists or a NumPy array representing the basis vectors.

    Returns:
        A list of Cartesian coordinates of the vector in the new basis.
    """
    coefficients = np.linalg.solve(np.array(basis).T, vector)
    return coefficients

# Problem 1
a = np.array([3, 4])
length_a = vector_length(a)
scalar_multiple = 1 / length_a
print(f"Problem 1: Scalar multiple to make vector a unit vector: {scalar_multiple}")

# Problem 2
b = np.array([1, 1])
length_b = vector_length(b)
unit_b = unit_vector(b)
print(f"Problem 2: Length of vector b: {length_b}")
print(f"Problem 2: Unit vector of b: {unit_b}")

# Problem 3
plt.figure()
plt.quiver(0, 0, b[0], b[1], angles='xy', scale_units='xy', scale=1, color='r', label='Vector b')
plt.quiver(0, 0, unit_b[0], unit_b[1], angles='xy', scale_units='xy', scale=1, color='b', label='Unit vector of b')
plt.xlim(-2, 2)
plt.ylim(-2, 2)
plt.grid()
plt.legend()
plt.show()

# Problem 4
c = np.array([1, 2, 3])
length_c = vector_length(c)
unit_c = unit_vector(c)
print(f"Problem 4: Length of vector c: {length_c}")
print(f"Problem 4: Unit vector of c: {unit_c}")

# Problem 5
v = np.array([2, 3, 4])
basis = [[1, 0, 1], [0, 1, 0], [1, 0, -1]]
cartesian_coordinates = change_basis(v, basis)
print(f"Problem 5: Cartesian coordinates of vector v in the given basis: {cartesian_coordinates}")

#vectors 2
import numpy as np
import matplotlib.pyplot as plt

def vector_addition(v1, v2):
    """
    Performs vector addition.

    Args:
        v1: The first vector.
        v2: The second vector.

    Returns:
        The sum of the two vectors.
    """
    return v1 + v2

def vector_length(v):
    """
    Calculates the length (magnitude) of a vector.

    Args:
        v: The vector.

    Returns:
        The length of the vector.
    """
    return np.linalg.norm(v)

def vector_cross_product(v1, v2):
    """
    Calculates the cross product of two vectors.

    Args:
        v1: The first vector.
        v2: The second vector.

    Returns:
        The cross product of the two vectors.
    """
    return np.cross(v1, v2)

def vector_dot_product(v1, v2):
    """
    Calculates the dot product of two vectors.

    Args:
        v1: The first vector.
        v2: The second vector.

    Returns:
        The dot product of the two vectors.
    """
    return np.dot(v1, v2)

def angle_between_vectors(v1, v2):
    """
    Calculates the angle between two vectors in degrees.

    Args:
        v1: The first vector.
        v2: The second vector.

    Returns:
        The angle between the vectors in degrees.
    """
    dot_product = vector_dot_product(v1, v2)
    lengths_product = vector_length(v1) * vector_length(v2)
    cos_theta = dot_product / lengths_product
    return np.arccos(cos_theta) * 180 / np.pi

# Problem 1
v1 = np.array([2, 1])
v2 = np.array([-1, 1])
v_sum = vector_addition(v1, v2)

plt.figure()
plt.quiver(0, 0, v1[0], v1[1], angles='xy', scale_units='xy', scale=1, color='r', label='Vector v1')
plt.quiver(0, 0, v2[0], v2[1], angles='xy', scale_units='xy', scale=1, color='b', label='Vector v2')
plt.quiver(0, 0, v_sum[0], v_sum[1], angles='xy', scale_units='xy', scale=1, color='g', label='Vector v1 + v2')
plt.xlim(-2, 2

#vectors3
import numpy as np
import matplotlib.pyplot as plt

def vector_addition(v1, v2):
    """
    Performs vector addition.

    Args:
        v1: The first vector.
        v2: The second vector.

    Returns:
        The sum of the two vectors.
    """
    return v1 + v2

def vector_length(v):
    """
    Calculates the length (magnitude) of a vector.

    Args:
        v: The vector.

    Returns:
        The length of the vector.
    """
    return np.linalg.norm(v)

def vector_cross_product(v1, v2):
    """
    Calculates the cross product of two vectors.

    Args:
        v1: The first vector.
        v2: The second vector.

    Returns:
        The cross product of the two vectors.
    """
    return np.cross(v1, v2)

def vector_dot_product(v1, v2):
    """
    Calculates the dot product of two vectors.

    Args:
        v1: The first vector.
        v2: The second vector.

    Returns:
        The dot product of the two vectors.
    """
    return np.dot(v1, v2)

def angle_between_vectors(v1, v2):
    """
    Calculates the angle between two vectors in degrees.

    Args:
        v1: The first vector.
        v2: The second vector.

    Returns:
        The angle between the vectors in degrees.
    """
    dot_product = vector_dot_product(v1, v2)
    lengths_product = vector_length(v1) * vector_length(v2)
    cos_theta = dot_product / lengths_product
    return np.arccos(cos_theta) * 180 / np.pi

# Problem 1
v1 = np.array([2, 1])
v2 = np.array([-1, 1])
v_sum = vector_addition(v1, v2)

plt.figure()
plt.quiver(0, 0, v1[0], v1[1], angles='xy', scale_units='xy', scale=1, color='r', label='Vector v1')
plt.quiver(0, 0, v2[0], v2[1], angles='xy', scale_units='xy', scale=1, color='b', label='Vector v2')
plt.quiver(0, 0, v_sum[0], v_sum[1], angles='xy', scale_units='xy', scale=1, color='g', label='Vector v1 + v2')
plt.xlim(-2, 2

#Equations of lines on a plane


import numpy as np
import matplotlib.pyplot as plt

def line_equation_from_points(p1, p2):
    """
    Finds the equation of the line passing through two points.

    Args:
        p1: Coordinates of the first point (x1, y1).
        p2: Coordinates of the second point (x2, y2).

    Returns:
        A tuple (a, b, c) representing the equation of the line in the form ax + by + c = 0.
    """
    x1, y1 = p1
    x2, y2 = p2
    a = y2 - y1
    b = -(x2 - x1)
    c = x1 * y2 - x2 * y1
    return a, b, c

def line_equation_parallel(point, line_equation):
    """
    Finds the equation of a line parallel to a given line and passing through a point.

    Args:
        point: Coordinates of the point (x, y).
        line_equation: Tuple (a, b, c) representing the equation of the line.

    Returns:
        A tuple (a, b, c) representing the equation of the parallel line.
    """
    a, b, c = line_equation
    return a, b, -(a * point[0] + b * point[1])

def line_equation_perpendicular(point, line_equation):
    """
    Finds the equation of a line perpendicular to a given line and passing through a point.

    Args:
        point: Coordinates of the point (x, y).
        line_equation: Tuple (a, b, c) representing the equation of the line.

    Returns:
        A tuple (a, b, c) representing the equation of the perpendicular line.
    """
    a, b, c = line_equation
    return b, -a, -(b * point[0] - a * point[1])

def line_intersection(line1, line2):
    """
    Finds the intersection point of two lines.

    Args:
        line1: Tuple (a1, b1, c1) representing the equation of the first line.
        line2: Tuple (a2, b2, c2) representing the equation of the second line.

    Returns:
        Coordinates of the intersection point as a tuple (x, y), or None if the lines are parallel.
    """
    a1, b1, c1 = line1
    a2, b2, c2 = line2

    if a1 * b2 == a2 * b1:
        return None  # Lines are parallel

    x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1)
    y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1)

    return x, y

def angle_between_lines(line1, line2):
    """
    Calculates the angle between two lines.

    Args:
        line1: Tuple (a1, b1, c1) representing the equation of the first line.
        line2: Tuple (a2, b2, c2) representing the equation of the second line.

    Returns:
        The angle between the lines in radians.
    """
    m1 = -a1 / b1
    m2 = -a2 / b2
    return np.arctan2(m2 - m1, 1 + m1 * m2)

def distance_point_to_line(point, line_equation):
    """
    Calculates the distance from a point to a line.

    Args:
        point: Coordinates of the point (x, y).
        line_equation: Tuple (a, b, c) representing the equation of the line.

    Returns:
        The distance from the point to the line.
    """
    a, b, c = line_equation
    x, y = point
    return abs(a * x + b * y + c) / np.sqrt(a**2 + b**2)

# Problem 1
A = (1, 2)
B = (3, 4)
line1_equation = line_equation_from_points(A, B)
print(f"Problem 1: Equation of the line passing through A and B: {line1_equation}")

# Problem 2
line2_equation = (1, -2, 1)  # y = 2x - 1
line_parallel_equation = line_equation_parallel(A, line2_equation)
print(f"Problem 2: Equation of the line parallel to y = 2x - 1 and passing through A: {line_parallel_equation}")

# Problem 3
line_perpendicular_equation = line_equation_perpendicular(A, line2_equation)
print(f"Problem 3: Equation of the line perpendicular to y = 2x - 1 and passing through A: {line_perpendicular_equation}")

# Problem 4
line3_equation = (3, -2, -2)  # 3x - 2y - 2 = 0
line4_equation = (2, -3, 2)  # 2x - 3y + 2 = 0
intersection_point = line_intersection(line3_equation, line4_equation)
angle = angle_between_lines(line3_equation, line4_equation)
print(f"Problem 4: Intersection point of the lines: {intersection_point}")
print(f"Problem 4: Angle between the lines: {angle:.2f} radians")

# Problem 5
v = np.array([2, 3])
line_parallel_to_vector_equation = (-v[1], v[0], v[1] * A[0] - v[0] * A[1])
print(f"Problem 5: Equation of the line passing through A and parallel to vector [2, 3]: {line_parallel_to_vector_equation}")

# Problem 6
line5_equation = (1, 1, 1)  # x + y + 1 = 0
line_perpendicular_equation = line_equation_perpendicular((0, 0), line5_equation)
line_parallel_equation = line_equation_parallel((0, 0), line5_equation)
print(f"Problem 6: Example of a line perpendicular to x + y + 1 = 0: {line_perpendicular_equation}")
print(f"Problem 6: Example of a line parallel to x + y + 1 = 0: {line_parallel_equation}")

# Problem 7
distance = distance_point_to_line(A, line2_equation)
print(f"Problem 7: Distance from point A to the line y = 2x + 3: {distance}")

# Problem 8
A = (2, 0)
B = (0, 3)
line_equation_from_points = line_equation_from_points(A, B)
print(f"Problem 8: Equation of the line passing through A(2, 0) and B(0, 3): {line_equation_from_points}")

# Problem 9
line6_equation = (1, -1, -3)  # y = x + 3
angle = np.arctan2(1, 1)  # Slope of the line is 1
print(f"Problem 9: Angle between the line y = x + 3 and the Ox axis: {angle:.2f} radians")

# Problem 10
line7_equation = (1, 1, 1)  # x + y + 1 = 0
perpendicular_vector = np.array([1, 1])
print(f"Problem 10: A vector perpendicular to the line x + y + 1 = 0: {perpendicular_vector}")

#Equations of second-order curves (conic sections)

import numpy as np

def circle_equation(center, radius):
    """
    Finds the equation of a circle given its center and radius.

    Args:
        center: A tuple representing the center coordinates (x, y).
        radius: The radius of the circle.

    Returns:
        A string representing the equation of the circle in the form (x-a)^2 + (y-b)^2 = r^2.
    """
    x0, y0 = center
    return f"(x - {x0})^2 + (y - {y0})^2 = {radius}^2"

center = (1, 2)
radius = 3
circle_eq = circle_equation(center, radius)
print("Equation of the circle:", circle_eq)

#Equations of planes in space


import numpy as np

def plane_equation_from_points(A, B, C):
    """
    Finds the equation of the plane passing through three points.

    Args:
        A: Coordinates of the first point (x1, y1, z1).
        B: Coordinates of the second point (x2, y2, z2).
        C: Coordinates of the third point (x3, y3, z3).

    Returns:
        A tuple (a, b, c, d) representing the equation of the plane in the form ax + by + cz + d = 0.
    """
    # Calculate the normal vector to the plane using cross product of vectors AB and AC
    AB = np.array(B) - np.array(A)
    AC = np.array(C) - np.array(A)
    normal_vector = np.cross(AB, AC)

    # Calculate the value of d
    a, b, c = normal_vector
    d = -np.dot(normal_vector, np.array(A))

    return a, b, c, d

def plane_equation_parallel(point, plane_equation):
    """
    Finds the equation of a plane parallel to a given plane and passing through a point.

    Args:
        point: Coordinates of the point (x, y, z).
        plane_equation: Tuple (a, b, c, d) representing the equation of the plane.

    Returns:
        A tuple (a, b, c, d) representing the equation of the parallel plane.
    """
    a, b, c, d = plane_equation
    return a, b, c, -(a * point[0] + b * point[1] + c * point[2])

def plane_equation_perpendicular(point, normal_vector):
    """
    Finds the equation of a plane perpendicular to a given vector and passing through a point.

    Args:
        point: Coordinates of the point (x, y, z).
        normal_vector: A NumPy array representing the normal vector.

    Returns:
        A tuple (a, b, c, d) representing the equation of the perpendicular plane.
    """
    a, b, c = normal_vector
    return a, b, c, -(a * point[0] + b * point[1] + c * point[2])

def line_of_intersection(plane1_equation, plane2_equation):
    """
    Finds the line of intersection of two planes.

    Args:
        plane1_equation: Tuple (a1, b1, c1, d1) representing the equation of the first plane.
        plane2_equation: Tuple (a2, b2, c2, d2) representing the equation of the second plane.

    Returns:
        A tuple representing the parametric equations of the line of intersection, or None if the planes are parallel.
    """
    # ... (Implementation of line intersection calculation using vector and parametric equations)
    # This part requires solving a system of equations and finding the parametric representation of the line.
    # The implementation would be more complex and is omitted for brevity.

def plane_equation_from_vectors(point, v1, v2):
    """
    Finds the equation of the plane passing through a point and parallel to two vectors.

    Args:
        point: Coordinates of the point (x, y, z).
        v1: The first vector.
        v2: The second vector.

    Returns:
        A tuple (a, b, c, d) representing the equation of the plane.
    """
    normal_vector = np.cross(v1, v2)
    return plane_equation_perpendicular(point, normal_vector)

def distance_point_to_plane(point, plane_equation):
    """
    Calculates the distance from a point to a

#17. Equations of second-order surfaces


import numpy as np

def sphere_equation(center, radius):
    """
    Finds the equation of a sphere given its center and radius.

    Args:
        center: A tuple representing the center coordinates (x, y, z).
        radius: The radius of the sphere.

    Returns:
        A string representing the equation of the sphere in the form (x-a)^2 + (y-b)^2 + (z-c)^2 = r^2.
    """
    x0, y0, z0 = center
    return f"(x - {x0})^2 + (y - {y0})^2 + (z - {z0})^2 = {radius}^2"

center = (1, 2, 3)
radius = 3
sphere_eq = sphere_equation(center, radius)
print("Equation of the sphere:", sphere_eq)

#Functions

import matplotlib.pyplot as plt
import numpy as np

# Define the functions
def f(x):
    return x**2

def g(x):
    return np.sqrt(x)

def h(x):
    return 1/x

def j(x):
    return np.sin(x)

# Create an array of x values
x = np.linspace(0, 5, 100)

# Calculate function values
y_f = f(x)
y_g = g(x)
y_h = h(x)
y_j = j(x)

# Plot the functions
plt.figure(figsize=(10, 6))
plt.plot(x, y_f, label='f(x) = x^2')
plt.plot(x, y_g, label='g(x) = √x')
plt.plot(x, y_h, label='h(x) = 1/x')
plt.plot(x, y_j, label='j(x) = sin(x)')
plt.xlabel('x')
plt.ylabel('y')
plt.title('Functions')
plt.legend()
plt.grid(True)
plt.show()

# Find values at x = 2
print(f"f(2) = {f(2)}")
print(f"g(2) = {g(2)}")
print(f"h(2) = {h(2)}")
print(f"j(2) = {j(2)}")

#Limits of Sequences

import math

def calculate_limit_1(n):
    return (n**2 + 3*n) / (2*n**2 - 2*n)

# Calculate the limit numerically (approximation)
n_values = np.arange(100, 1000, 100)
limit_values = [calculate_limit_1(n) for n in n_values]

print("Approximate limit:", limit_values[-1])  # Print the last value as an approximation

# Analytical solution
# Divide both numerator and denominator by n^2
# lim_{n→∞} (1 + 3/n) / (2 - 2/n) = 1/2
print("Analytical limit:", 1/2)

#Limits of Real Functions

import numpy as np

def calculate_limit_1(x):
    return (x**3 + 2*x**2) / (x**4 - 3*x**3)

# Calculate the limit numerically (approximation)
x_values = np.arange(100, 1000, 100)
limit_values = [calculate_limit_1(x) for x in x_values]

print("Approximate limit:", limit_values[-1])  # Print the last value as an approximation

# Analytical solution
# Divide both numerator and denominator by x^4
# lim_{x→∞} (1/x + 2/x^2) / (1 - 3/x) = 0
print("Analytical limit:", 0)

erivatives
import math

def derivative(func, x):
    """Calculates the derivative of a function using the central difference method."""
    h = 1e-6  # Step size for numerical differentiation
    return (func(x + h) - func(x - h)) / (2 * h)

# Define the functions
def y1(x):
    return -3*x + 3

def y2(x):
    return math.pi*x + math.sin(1)

def y3(x):
    return 4 + math.sin(2)

def y4(x):
    return 2*x**3 - 3*x**2 + 8*x - 9

def y5(x):
    return 6*x**(1/3)

def y6(x):
    return math.sqrt(x)

def y7(x):
    return math.cos(x) + math.sin(x)

def y8(x):
    return 2*math.log(x)*math.cos(x)

def y9(x):
    return x*math.sin(x)

def y10(x):
    return (x+1)*(x+1)

def y11(x):
    return x/(x+1)

def y12(x):
    return (x+1)*math.exp(x)

def y13(x):
    return math.log(x**2)

def y14(x):
    return math.exp(-2*x)

def y15(x):
    return 1/math.sin(x+1)

def y16(x):
    return math.sqrt(2*x+1)

# Evaluate the derivatives at a specific point (e.g., x = 2)
x_value = 2

print("Derivatives at x =", x_value)
print("y1:", derivative(y1, x_value))
print("y2:", derivative(y2, x_value))
print("y3:", derivative(y3, x_value))
print("y4:", derivative(y4, x_value))
print("y5:", derivative(y5, x_value))
print("y6:", derivative(y6, x_value))
print("y7:", derivative(y7, x_value))
print("y8:", derivative(y8, x_value))
print("y9:", derivative(y9, x_value))
print("y10:", derivative(y10, x_value))
print("y11:", derivative(y11, x_value))
print("y12:", derivative(y12, x_value))
print("y13:", derivative(y13, x_value))
print("y14:", derivative(y14, x_value))
print("y15:", derivative(y15, x_value))
print("y16:", derivative(y16, x_value))

import math

def derivative(func, x):
    """Calculates the derivative of a function using the central difference method."""
    h = 1e-6  # Step size for numerical differentiation
    return (func(x + h) - func(x - h)) / (2 * h)

def ln_sin(x):
    return math.log(math.sin(x))

def cot(x):
    return 1 / math.tan(x)

x_value = math.pi/4  # Example value for x

# Calculate the derivative of ln(sin(x))
derivative_ln_sin = derivative(ln_sin, x_value)

# Calculate cot(x)
cot_x = cot(x_value)

# Compare the results
print("Derivative of ln(sin(x)) at x =", x_value, ":", derivative_ln_sin)
print("cot(x) at x =", x_value, ":", cot_x)

if abs(derivative_ln_sin - cot_x) < 1e-5:  # Tolerance for comparison
    print("The derivative of ln(sin(x)) is equal to cot(x)")
else:
    print("The derivative of ln(sin(x)) is not equal to cot(x)")

    import math

def derivative(func, x):
    """Calculates the derivative of a function using the central difference method."""
    h = 1e-6  # Step size for numerical differentiation
    return (func(x + h) - func(x - h)) / (2 * h)

def cos_function(x):
    return math.cos(x)

x_value = math.pi/4  # Example value for x

# Calculate the derivative of cos(x)
derivative_cos = derivative(cos_function, x_value)

# Calculate -f(x)
negative_cos = -math.cos(x_value)

# Compare the results
print("Derivative of cos(x) at x =", x_value, ":", derivative_cos)
print("-f(x) at x =", x_value, ":", negative_cos)

if abs(derivative_cos - negative_cos) < 1e-5:  # Tolerance for comparison
    print("f'(x) is equal to -f(x)")
else:
    print("f'(x) is not equal to -f(x)")

    import math

def lhospital(func1, func2, x):
    """Applies l'Hospital's Rule to find the limit of func1/func2 as x approaches a."""
    h = 1e-6  # Step size for numerical differentiation
    derivative_func1 = (func1(x + h) - func1(x - h)) / (2 * h)
    derivative_func2 = (func2(x + h) - func2(x - h)) / (2 * h)
    return derivative_func1 / derivative_func2

# Define the functions
def func1_a(x):
    return math.sin(x)

def func2_a(x):
    return x

def func1_b(x):
    return math.log(x)

def func2_b(x):
    return x

def func1_c(x):
    return math.exp(x)

def func2_c(x):
    return x

# Apply l'Hospital's Rule
limit_a = lhospital(func1_a, func2_a, 0)
limit_b = lhospital(func1_b, func2_b, math.inf)  # Note: math.inf represents infinity
limit_c = lhospital(func1_c, func2_c, math.inf)

print("Limit of sin(x)/x as x approaches 0:", limit_a)
print("Limit of ln(x)/x as x approaches infinity:", limit_b)
print("Limit of exp(x)/x as x approaches infinity:", limit_c)

def position(t):
    return 3*t**2 - 6*t + 1

def derivative(func, t):
    """Calculates the derivative of a function using the central difference method."""
    h = 1e-6  # Step size for numerical differentiation
    return (func(t + h) - func(t - h)) / (2 * h)

t_value = 2

# Calculate velocity (derivative of position)
velocity = derivative(position, t_value)

# Calculate acceleration (derivative of velocity)
acceleration = derivative(lambda t: derivative(position, t), t_value)

print("Velocity at t =", t_value, ":", velocity)
print("Acceleration at t =", t_value, ":", acceleration)

#Extremum

import numpy as np

def profit_function(u):
    return -2*u**2 + 50*u - 300

# Find the vertex of the parabola (maximum point)
u_vertex = -b / (2*a)  # where a = -2, b = 50

# Calculate the number of units for maximum profit
max_units = int(u_vertex)  # Round to the nearest integer

print("Number of units that maximize profit:", max_units)

import numpy as np

def rectangle_area(l):
    # Calculate the area of the rectangle given one side length
    w = (10 - 2*l) / 2  # Calculate the width based on the perimeter
    return l * w

# Find the maximum area using optimization
l_values = np.linspace(0, 5, 100)  # Create an array of possible side lengths
areas = rectangle_area(l_values)
max_area = np.max(areas)
max_index = np.argmax(areas)
max_length = l_values[max_index]
max_width = (10 - 2*max_length) / 2

print("Dimensions of the rectangle for maximum area:")
print("Length:", max_length)
print("Width:", max_width)

import numpy as np

def function(x):
    return x**2 + 3*x - 5

# Find the derivative of the function
def derivative(func, x):
    h = 1e-6  # Step size for numerical differentiation
    return (func(x + h) - func(x - h)) / (2 * h)

# Find the critical points (where derivative is zero)
x_values = np.linspace(-5, 5, 100)  # Create an array of x values
derivatives = [derivative(function, x) for x in x_values]
critical_points = x_values[np.abs(derivatives) < 1e-5]  # Find points where derivative is approximately zero

# Determine if the critical points are maxima or minima
extrema = []
for point in critical_points:
    if derivative(function, point - 1e-5) < 0 and derivative(function, point + 1e-5) > 0:
        extrema.append(("Minimum", point, function(point)))
    elif derivative(function, point - 1e-5) > 0 and derivative(function, point + 1e-5) < 0:
        extrema.append(("Maximum", point, function(point)))

# Print the results
for extremum in extrema:
    print(f"Extremum: {extremum[0]} at x = {extremum[1]}, f(x) = {extremum[2]}")

    import numpy as np

def function(x):
    return (x**2 + 2*x + 1) / (x - 1)

# Find the derivative of the function
def derivative(func, x):
    h = 1e-6  # Step size for numerical differentiation
    return (func(x + h) - func(x - h)) / (2 * h)

# Find the critical points (where derivative is zero)
x_values = np.linspace(-5, 5, 100)  # Create an array of x values
derivatives = [derivative(function, x) for x in x_values]
critical_points = x_values[np.abs(derivatives) < 1e-5]  # Find points where derivative is approximately zero

# Determine if the critical points are maxima or minima
extrema = []
for point in critical_points:
    if derivative(function, point - 1e-5) < 0 and derivative(function, point + 1e-5) > 0:
        extrema.append(("Minimum", point, function(point)))
    elif derivative(function, point - 1e-5) > 0 and derivative(function, point + 1e-5) < 0:
        extrema.append(("Maximum", point, function(point)))

# Print the results
for extremum in extrema:
    print(f"Extremum: {extremum[0]} at x = {extremum[1]}, f(x) = {extremum[2]}")

#Taylor Series

import matplotlib.pyplot as plt
import numpy as np

# Define the function
def cos_x(x):
    return np.cos(x)

# Define the Taylor series approximation
def taylor_cos(x):
    return 1 - (x**2)/2 + (x**4)/24

# Generate x values for plotting
x_values = np.linspace(-np.pi, np.pi, 100)

# Calculate the function values and Taylor series approximations
y_cos = cos_x(x_values)
y_taylor = taylor_cos(x_values)

# Plot the results
plt.plot(x_values, y_cos, label='cos(x)')
plt.plot(x_values, y_taylor, label='Taylor Series')
plt.legend()
plt.xlabel('x')
plt.ylabel('y')
plt.title('Taylor Series of cos(x) around x=0')
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt
import numpy as np

# Define the function
def h_x(x):
    return 1 / (1 - x)

# Define the Taylor series approximation
def taylor_h(x):
    return 1 + x + x**2 + x**3

# Generate x values for plotting
x_values = np.linspace(-0.9, 0.9, 100)  # Avoid x = 1 where h(x) is undefined

# Calculate the function values and Taylor series approximations
y_h = h_x(x_values)
y_taylor = taylor_h(x_values)

# Plot the results
plt.plot(x_values, y_h, label='h(x)')
plt.plot(x_values, y_taylor, label='Taylor Series')
plt.legend()
plt.xlabel('x')
plt.ylabel('y')
plt.title('Taylor Series of h(x) around x=0')
plt.grid(True)
plt.show()

import numpy as np
import matplotlib.pyplot as plt

# Define the function
def f_x(x):
    return np.exp(np.sin(x))

# Define the derivative of the function
def df_dx(x):
    return np.cos(x) * np.exp(np.sin(x))

# Calculate the values at xo = π
xo = np.pi
f_xo = f_x(xo)
df_dx_xo = df_dx(xo)

# Define the tangent line equation
def tangent_line(x):
    return df_dx_xo * (x - xo) + f_xo

# Generate x values for plotting
x_values = np.linspace(0, 2*np.pi, 100)

# Calculate the function values and tangent line values
y_f = f_x(x_values)
y_tangent = tangent_line(x_values)

# Plot the results
plt.plot(x_values, y_f, label='f(x)')
plt.plot(x_values, y_tangent, label='Tangent Line')
plt.legend()
plt.xlabel('x')
plt.ylabel('y')
plt.title('Tangent Line to f(x) at x=π')
plt.grid(True)
plt.show()

#Integrals

import sympy as sp

# Define the symbolic variable
x = sp.Symbol('x')

# Compute the integrals
integral1 = sp.integrate(x**2 + 2*x + 3, x)
integral2 = sp.integrate(2*sp.sin(x), x)
integral3 = sp.integrate(3/x, x)
integral4 = sp.integrate(1/x**2, x)
integral5 = sp.integrate((x-5)**2, x)
integral6 = sp.integrate(sp.sin(x)**2 + sp.cos(x)**2, x)
integral7 = sp.integrate(5*sp.sin(x) + 3*sp.exp(x), x)
integral8 = sp.integrate(sp.sqrt(x), x)
integral9 = sp.integrate(sp.sqrt(10*x), x)
integral10 = sp.integrate(sp.cos(5/2*x + 3), x)
integral11 = sp.integrate(sp.cos(sp.log(x))/x, x)
integral12 = sp.integrate(x*sp.log(x), x)
integral13 = sp.integrate(x*sp.exp(x), x)

# Print the results
print("Integral 1:", integral1)
print("Integral 2:", integral2)
print("Integral 3:", integral3)
print("Integral 4:", integral4)
print("Integral 5:", integral5)
print("Integral 6:", integral6)
print("Integral 7:", integral7)
print("Integral 8:", integral8)
print("Integral 9:", integral9)
print("Integral 10:", integral10)
print("Integral 11:", integral11)
print("Integral 12:", integral12)
print("Integral 13:", integral13)

import sympy as sp
import matplotlib.pyplot as plt
import numpy as np

# Define the symbolic variable
x = sp.Symbol('x')

# Define the functions
f_x = 2*x + 1
g_x = x**2

# Calculate the definite integrals
integral_f = sp.integrate(f_x, (x, 0, sp.pi))
integral_g = sp.integrate(g_x, (x, 0, sp.pi))

# Print the results
print("Integral of f(x) over [0, π]:", integral_f)
print("Integral of g(x) over [0, π]:", integral_g)

# Generate x values for plotting
x_values = np.linspace(0, np.pi, 100)

# Calculate the function values
y_f = [f_x.subs(x, x_val) for x_val in x_values]
y_g = [g_x.subs(x, x_val) for x_val in x_values]

# Plot the results
plt.plot(x_values, y_f, label='f(x)')
plt.plot(x_values, y_g, label='g(x)')
plt.fill_between(x_values, y_f, alpha=0.2)
plt.fill_between(x_values, y_g, alpha=0.2)
plt.legend()
plt.xlabel('x')
plt.ylabel('y')
plt.title('Integrals over [0, π]')
plt.grid(True)
plt.show()

import sympy as sp
import matplotlib.pyplot as plt
import numpy as np

# Define the symbolic variable
x = sp.Symbol('x')

# Define the function
y = x**2 + 1

# Calculate the definite integral
area = sp.integrate(y, (x, 1, 2))

# Print the result
print("Area of the region:", area)

# Generate x values for plotting
x_values = np.linspace(1, 2, 100)

# Calculate the function values
y_values = [y.subs(x, x_val) for x_val in x_values]

# Plot the results
plt.plot(x_values, y_values)
plt.fill_between(x_values, y_values, alpha=0.2)
plt.xlabel('x')
plt.ylabel('y')
plt.title('Area of the Region')
plt.grid(True)
plt.show()

import sympy as sp

# Define the symbolic variable
x = sp.Symbol('x')

# Calculate the derivative of sin(x)
df_dx = sp.diff(sp.sin(x), x)

# Calculate the length of the curve
length = sp.integrate(sp.sqrt(1 + df_dx**2), (x, 0, sp.pi))

# Print the result
print("Length of the sine curve:", length)

import sympy as sp

# Define the symbolic variable
t = sp.Symbol('t')

# Define the position function
x_t = 3*t**2 - 6*t + 1

# Calculate the velocity function (derivative of position)
v_t = sp.diff(x_t, t)

# Calculate the distance traveled
distance = sp.integrate(abs(v_t), (t, 0, 2))

# Print the result
print("Distance traveled by the particle:", distance)

#Differential Equations

import numpy as np
import matplotlib.pyplot as plt

# Define the solutions as functions
def y1(x):
    return np.exp(-x) + 1

def y2(x):
    return 2 * np.cosh(x)

def y3(x, omega, C1, C2):
    return C1 * np.cos(omega * x) + C2 * np.sin(omega * x)

# Define the wave function
def u(t, x, A, a, k):
    return A * np.cos(a * t + k * x)

# Set parameters for visualization
omega = 1
C1 = 1
C2 = 1
A = 1
a = 2 * np.pi
k = 2 * np.pi
T = 1
lambda_ = 1
c = lambda_ / T

# Generate x values for plotting
x_values = np.linspace(-5, 5, 100)

# Plot the solutions
plt.figure(figsize=(12, 4))

plt.subplot(1, 3, 1)
plt.plot(x_values, y1(x_values))
plt.title("y1(x) = 1 + e^(-x)")

plt.subplot(1, 3, 2)
plt.plot(x_values, y2(x_values))
plt.title("y2(x) = 2cosh(x)")

plt.subplot(1, 3, 3)
plt.plot(x_values, y3(x_values, omega, C1, C2))
plt.title("y3(x) = C1cos(ωx) + C2sin(ωx)")

plt.tight_layout()
plt.show()

# Generate t and x values for plotting the wave function
t_values = np.linspace(0, 2 * T, 100)
x_values = np.linspace(-2 * lambda_, 2 * lambda_, 100)
T, X = np.meshgrid(t_values, x_values)

# Calculate the wave function values
U = u(T, X, A, a, k)

# Plot the wave function
plt.figure()
plt.imshow(U, extent=[0, 2 * T, -2 * lambda_, 2 * lambda_], cmap='viridis', aspect='auto')
plt.xlabel('Time (t)')
plt.ylabel('Position (x)')
plt.title('Wave Function u(t, x)')
plt.colorbar()
plt.show()
